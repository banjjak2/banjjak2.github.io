[ { "title": "앱 아이콘이 런처에 보이지 않는 문제", "url": "/posts/%EC%95%B1-%EC%95%84%EC%9D%B4%EC%BD%98%EC%9D%B4-%EB%9F%B0%EC%B2%98%EC%97%90-%EB%B3%B4%EC%9D%B4%EC%A7%80-%EC%95%8A%EB%8A%94-%EB%AC%B8%EC%A0%9C/", "categories": "Android, 문제해결", "tags": "Android, 문제해결", "date": "2022-06-22 02:53:47 +0900", "snippet": "앱 아이콘이 런처에 보이지 않는 문제Github OAuth를 적용하기 위해 처음에 아래처럼 intent-filter 를 구성했다. 그런데 적용한 후 실행해보니 앱의 아이콘이 앱 런처에 나타나지 않았다.&amp;lt;activity android:name=&quot;.presentation.login.LoginActivity&quot; android:exported=&quot;true&quot; android:launchMode=&quot;singleTask&quot;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt; &amp;lt;action android:name=&quot;android.intent.action.VIEW&quot; /&amp;gt; &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt; &amp;lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&amp;gt; &amp;lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&amp;gt; &amp;lt;data android:host=&quot;com.example.it.issuetracker&quot; android:scheme=&quot;issuetracker&quot; /&amp;gt; &amp;lt;/intent-filter&amp;gt;&amp;lt;/activity&amp;gt;그래서 찾아본 결과, 아래와 같이 intent-filter 를 따로 구성해야 한다.&amp;lt;activity android:name=&quot;.presentation.login.LoginActivity&quot; android:exported=&quot;true&quot; android:launchMode=&quot;singleTask&quot;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt; &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&quot;android.intent.action.VIEW&quot; /&amp;gt; &amp;lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&amp;gt; &amp;lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&amp;gt; &amp;lt;data android:host=&quot;com.example.it.issuetracker&quot; android:scheme=&quot;issuetracker&quot; /&amp;gt; &amp;lt;/intent-filter&amp;gt;&amp;lt;/activity&amp;gt;먼저 인텐트 태그들에 대해서 간단히 얘기하자면 아래와 같다.action.MAIN : 앱의 진입점을 의미category.LAUNCHER : 앱 아이콘을 런처에 표시해주기 위함BROWSABLE : 앱 내부에서 브라우저를 열 수 있다. 이때 특정 앱의 intent-filter 에 data 태그가 존재한다면 해당 앱의 액티비티를 띄울 수도 있다. (딥 링크 이용)관련 내용 : https://developer.android.com/training/app-links/verify-site-associations?hl=ko위와 같이 사용해야하는 이유에 대해서 명확히 설명된 글이 없어서 여러 시도 끝에 나만의 결론을 내리자면, 암시적 인텐트 필터는 앱이 실행중이지 않더라도 요청이 들어오면 데이터를 받아 실행해야 한다. 그래서 BROWSABLE 이 설정된 인텐트 필터는 Instant 앱으로 실행되어야 하기 때문에 시스템 어딘가에 숨겨져 있고, 요청이 들어오면 숨겨진 해당 인텐트를 실행해주는 과정을 거치는 것 같다.PackageParser.java 어딘가..그래서 MAIN 과 LAUNCHER 가 선언된 intent-filter 에 BROWSABLE 을 추가하게 되면 앱 아이콘이 런처에서 사라지는게 아닌가 싶다.실제로, 위 manifest.xml 파일에서 launchMode 가 singleTask (앱이 실행되어 있으면 실행된 앱을 이용함) 로 설정되어 있는데, 이를 제거하게 되면 이미 앱이 실행되어 있더라도 해당 앱을 계속 사용하는 것이 아니라 새로운 앱을 실행하게 된다.제거 전D/test: onCreate제거 후D/test: onCreateD/test: onCreate" }, { "title": "[프로그래머스] 도둑질", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%8F%84%EB%91%91%EC%A7%88/", "categories": "Programmers, Problems", "tags": "Programmers", "date": "2022-06-19 16:32:12 +0900", "snippet": "문제 주소 https://programmers.co.kr/learn/courses/30/lessons/42897#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int solution(vector&amp;lt;int&amp;gt; money) { int answer = 0; int n = money.size(); vector&amp;lt;int&amp;gt; d1(n); vector&amp;lt;int&amp;gt; d2(n); // 첫번째 집을 털었을 때 // d1[i] = d1[i-2] + money[i] // i-2 =&amp;gt; 인접한 곳은 털 수 없으므로 i-2까지의 값을 더하기 위해 d1[0] = money[0]; d1[1] = d1[0]; // 인접한 i+1은 i값으로 대체 // 첫번째 집을 털지 않았을 때 d2[0] = 0; d2[1] = money[1]; for (int i=2; i&amp;lt;n; i++) { d1[i] = max(d1[i-2] + money[i], d1[i-1]); d2[i] = max(d2[i-2] + money[i], d2[i-1]); } return max(d1[n-2], d2[n-1]);}아이디어 첫번째 집을 털었을 때와 털지 않았을 때를 구분 점화식은 동일 : d[i] = d[i-2] + money[i] 초기 세팅값만 변경됨 첫번째 집을 털었을 경우 d1[0] = money[0] -&amp;gt; 첫번째 집을 털었으므로 돈을 입력 d1[1] = d1[0] -&amp;gt; 인접한 i+1은 d1[0]으로 대체 (인접한 곳은 털 수 없다고 했으므로) 첫번째 집을 털지 않았을 경우 d2[0] = 0 -&amp;gt; 첫번째 집을 털지 않았으므로 0 d2[1] = money[1] -&amp;gt; 첫번째 집 이후의 i+1은 털 수 있으므로 money[1] " }, { "title": "[프로그래머스] 등굣길", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%93%B1%EA%B5%A3%EA%B8%B8/", "categories": "Programmers, Problems", "tags": "Programmers", "date": "2022-06-19 16:15:18 +0900", "snippet": "문제 주소 https://programmers.co.kr/learn/courses/30/lessons/42898#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;// D[i][j] = D[i-1][j] + D[i][j-1];// puddles 행렬이 반대int solution(int m, int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; puddles) { int answer = 0; int map[101][101] = {0, }; for (const auto &amp;amp;p : puddles) { map[p[1]][p[0]] = -1; } map[1][1] = 1; for (int i=1; i&amp;lt;=n; i++) { for (int j=1; j&amp;lt;=m; j++) { if (i == 1 &amp;amp;&amp;amp; j == 1) continue; if (map[i][j] == -1) continue; map[i][j] += (map[i-1][j] == -1)? 0 : map[i-1][j]; map[i][j] %= 1000000007; map[i][j] += (map[i][j-1] == -1)? 0 : map[i][j-1]; map[i][j] %= 1000000007; } } return map[n][m];}아이디어 오른쪽과 아래쪽으로만 움직일 수 있다. 집 좌표 : (1, 1), 학교 좌표 : (n, m) 학교 좌표에서 왼쪽과 위쪽만 확인할 수 있다. 점화식 : D[i][j] = D[i-1][j] + D[i][j-1] 즉, D[n][m] = D[n-1][m] + D[n][m-1] 주의할 점 puddles의 좌표와 m, n의 좌표가 반대로 되어있음" }, { "title": "[프로그래머스] 단속카메라", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%8B%A8%EC%86%8D%EC%B9%B4%EB%A9%94%EB%9D%BC/", "categories": "Programmers, Problems", "tags": "Programmers", "date": "2022-06-05 17:22:48 +0900", "snippet": "풀이방법 진출지점으로 배열을 오름차순 정렬한다. 첫번째 차의 진출지점에는 무조건 카메라가 있어야 한다. 다음차들부터는 진입지점이 이전 차의 진출지점 이하일 경우에는 제거한다.#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;bool compare(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[1] &amp;lt; b[1]) { return true; } else { return false; }}int solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; routes) { int answer = 0; sort(routes.begin(), routes.end(), compare); list&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; carList(routes.begin(), routes.end()); int curCarEndPosition; while (!carList.empty()) { curCarEndPosition = carList.front()[1]; carList.pop_front(); int checkCount = carList.size(); list&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;::iterator iter = carList.begin(); int count = 0; for (iter=carList.begin(); iter!=carList.end();) { auto value = *iter; if (value[0] &amp;lt;= curCarEndPosition) { iter = carList.erase(iter); } else { iter++; } } answer++; } return answer;}" }, { "title": "[프로그래머스] 섬 연결하기", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%84%AC-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0/", "categories": "Programmers, Problems", "tags": "Programmers", "date": "2022-06-04 20:21:42 +0900", "snippet": "최소 신장 트리 문제 크루스칼 알고리즘 이용 바킹독 최소 신장 트리 참고했음#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;bool compare(vector&amp;lt;int&amp;gt; &amp;amp;a, const vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[2] &amp;gt; b[2]) { return false; } else { return true; }}int find(vector&amp;lt;int&amp;gt; &amp;amp;p, int x) { if (p[x] &amp;lt; 0) return x; return p[x] = find(p, p[x]);}bool is_diff_group(vector&amp;lt;int&amp;gt; &amp;amp;p, int x, int y) { x = find(p, x); y = find(p, y); if (x == y) return false; if (p[x] &amp;gt; p[y]) swap(x, y); p[x] += p[y]; p[y] = x; return true;}int solution(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; costs) { int answer = 0; int count = 0; sort(costs.begin(), costs.end(), compare); vector&amp;lt;int&amp;gt; p(n, -1); for (int i=0; i&amp;lt;costs.size(); i++) { if (!is_diff_group(p, costs[i][0], costs[i][1])) continue; answer += costs[i][2]; count++; if (count == n-1) break; } return answer;}" }, { "title": "[프로그래머스] 구명보트", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B5%AC%EB%AA%85%EB%B3%B4%ED%8A%B8/", "categories": "Programmers, Problems", "tags": "Programmers", "date": "2022-06-03 22:20:52 +0900", "snippet": "#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;/** * * 제한사항에서 구출할 수 없는 경우는 없다고 했으므로 모두 빠져 나갈때까지 반복문을 돌릴 수 있다. * * 1. 데이터를 정렬한다. * 2. 가장 무거운 애부터 차례대로 가져온다. * 3. 현재 가장 가벼운 애와 더했을 때 limit 이하인지 확인한다. * 4. 이하라면 구명보트를 탈 수 있으므로 둘 다 제거한다. * 5. 초과한다면 구명보트에는 가장 무거운 애만 탈 수 있으므로 가장 무거운 애만 제거한다. * */int solution(vector&amp;lt;int&amp;gt; people, int limit) { int answer = 0; sort(people.begin(), people.end()); deque&amp;lt;int&amp;gt; peopleDeque(people.begin(), people.end()); while (!peopleDeque.empty()) { int weight = peopleDeque.back(); if (peopleDeque.front() + weight &amp;lt;= limit) { peopleDeque.pop_front(); } if (!peopleDeque.empty()) peopleDeque.pop_back(); answer++; } return answer;}" }, { "title": "버튼 커스텀 drawable 적용이 안될 때", "url": "/posts/%EB%B2%84%ED%8A%BC-%EC%BB%A4%EC%8A%A4%ED%85%80-drawable-%EC%A0%81%EC%9A%A9%EC%9D%B4-%EC%95%88%EB%90%A0-%EB%95%8C/", "categories": "Android, 문제해결", "tags": "Android, 문제해결", "date": "2022-05-09 22:17:29 +0900", "snippet": "개요라운드된 버튼을 만들기 위해 drawable을 만들어 background에 사용하려고 했었다.drawable&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&amp;gt; &amp;lt;solid android:color=&quot;@color/green&quot;/&amp;gt; &amp;lt;corners android:radius=&quot;36dp&quot; /&amp;gt;&amp;lt;/shape&amp;gt;레이아웃&amp;lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@drawable/round_green_button&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&amp;gt;그런데 drawable에 적용한 solid 색상이 적용되지 않는 문제가 있었다.난 분명 초록색으로 설정했었는데…원인은 알 수 없지만..정확한 원인은 정확히 알 수 없으나.. 일반 Button이 MaterialButton의 디자인을 이용하고 있어서가 아닐까라는 추측이 들었다. 그 이유는 com.google.android.material.button.MaterialButton으로 바꿔서 테스트해봐도 동일한 문제가 있었고, 찾아본 결과 아래 내용을 확인할 수 있었다.요약하자면, MaterialButton에서는 android:background를 사용하지 말라는 뜻인데, 그 이유가 MaterialButton 자체에서 자체 background drawable을 소유하고 있고, 이것을 강제로 변경하게 되면 문제가 생길 수 있다는 뜻이다.해결방법인터넷에 나와있는 해결 방법은 여러가지이다. themes.xml에서 최상단 스타일에 DarkActionBar.Bridge로 변경해준다. 버튼 xml에서 app:backgroundTint=&quot;@null&quot;로 설정한다. primaryColor를 변경해준다. Button이나 MaterialButton대신 AppCompatButton을 이용한다.여기서 제일 깔끔하다고 생각하는건 차라리 AppCompatButton을 이용하는 것이다. 그 이유는 1번같은 경우 theme을 변경하는 것이기 때문에 프로젝트 전체가 변경될 위험성이 있다. 2번째는 매번 버튼을 만들고 custom drawable을 적용할 때마다 써줘야되는게 불합리적이라고 판단했다. 3번째는 primaryColor를 변경하면 이 역시 프로젝트 전체 디자인이 변경될 가능성이 있다. 그래서 4번을 선택했다.[참고] https://developer.android.com/reference/com/google/android/material/button/MaterialButton https://github.com/material-components/material-components-android/issues/889" }, { "title": "Coroutine 취소 및 예외처리", "url": "/posts/Coroutine-%EC%B7%A8%EC%86%8C-%EB%B0%8F-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/", "categories": "Kotlin, Coroutine", "tags": "Kotlin, Coroutine", "date": "2022-05-08 16:37:28 +0900", "snippet": "일반적인 코루틴 예외처리 방법 (CoroutineExceptionHandler)코루틴에서 예외를 처리하는 일반적인 방법은 CoroutineScope을 이용해 새 코루틴을 생성할 때 CoroutineExceptionHandler를 이용해 예외를 처리할 수 있다.코드import kotlinx.coroutines.*import java.io.IOExceptionimport kotlin.coroutines.cancellation.CancellationExceptionfun main() = runBlocking { val coroutineExceptionHandler = CoroutineExceptionHandler { _, throwable -&amp;gt; println(&quot;coroutineExceptionHandler -&amp;gt; $throwable&quot;) } val job = CoroutineScope(Dispatchers.Default + coroutineExceptionHandler).launch { val child1 = launch { try { throw IOException() // 예외 발생 delay(3000) println(&quot;child1 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child1 Exception -&amp;gt; ${e.message}&quot;) } } }.join() println(&quot;main&quot;)}결과coroutineExceptionHandler -&amp;gt; java.io.IOExceptionmain이렇게 함으로써 코루틴을 사용하는 도중에 예외가 발생했을 때 UI에 예외가 발생한 이유를 설명해주거나 다른 작업을 실행하도록 할 수 있다.코루틴 취소 및 예외 발생코루틴에서는 기본적으로 구조적 동시성때문에 부모 코루틴이 취소되거나 예외가 발생하면 부모 코루틴의 Scope에 있는 코루틴들은 모두 취소된다. (취소가 전파됨) 부모 코루틴 취소 시 코드 import kotlinx.coroutines.* import kotlin.coroutines.cancellation.CancellationException fun main() = runBlocking { val job = CoroutineScope(Dispatchers.Default).launch { val child1 = launch { try { delay(3000) println(&quot;child1 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child1 Exception -&amp;gt; ${e.message}&quot;) } } val child2 = launch { try { val child3 = launch { try { delay(3000) println(&quot;child 3 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child3 Exception -&amp;gt; ${e.message}&quot;) } } delay(3000) println(&quot;child 2 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child2 Exception -&amp;gt; ${e.message}&quot;) } } println(&quot;parent coroutine&quot;) } delay(2000) job.cancel() // 부모 코루틴 취소 println(&quot;main&quot;) } 결과 parent coroutine child1 Exception -&amp;gt; StandaloneCoroutine was cancelled main child 2 Exception -&amp;gt; StandaloneCoroutine was cancelled 부모 코루틴 예외 발생 시 코드 import kotlinx.coroutines.* import java.io.IOException import kotlin.coroutines.cancellation.CancellationException fun main() = runBlocking { val job = CoroutineScope(Dispatchers.Default).launch { val child1 = launch { try { delay(3000) println(&quot;child1 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child1 Exception -&amp;gt; ${e.message}&quot;) } } val child2 = launch { try { val child3 = launch { try { delay(3000) println(&quot;child 3 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child3 Exception -&amp;gt; ${e.message}&quot;) } } delay(3000) println(&quot;child 2 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child2 Exception -&amp;gt; ${e.message}&quot;) } } throw IOException() // 예외 발생 println(&quot;parent coroutine&quot;) } delay(2000) job.cancel() println(&quot;main&quot;) } 결과 child1 Exception -&amp;gt; Parent job is Cancelling child3 Exception -&amp;gt; Parent job is Cancelling child2 Exception -&amp;gt; Parent job is Cancelling Exception in thread &quot;DefaultDispatcher-worker-2&quot; java.io.IOException at CehKt$main$1$job$1.invokeSuspend(ceh.kt:34) at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106) at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:570) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:749) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:677) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:664) Suppressed: kotlinx.coroutines.DiagnosticCoroutineContextException: [StandaloneCoroutine{Cancelling}@55321535, Dispatchers.Default] main 만약 자식 코루틴에서 취소가 발생하면 해당 코루틴만 취소되고 다른 코루틴에 취소가 전파되지 않는다. 자식 코루틴 취소 시 코드 import kotlinx.coroutines.* import kotlin.coroutines.cancellation.CancellationException fun main() = runBlocking { val job = CoroutineScope(Dispatchers.Default).launch { val child1 = launch { try { delay(3000) println(&quot;child1 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child1 Exception -&amp;gt; ${e.message}&quot;) } } child1.cancel() // 자식 코루틴 취소 val child2 = launch { try { val child3 = launch { try { delay(3000) println(&quot;child 3 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child3 Exception -&amp;gt; ${e.message}&quot;) } } delay(3000) println(&quot;child 2 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child2 Exception -&amp;gt; ${e.message}&quot;) } } delay(1000) println(&quot;parent coroutine&quot;) }.join() println(&quot;main&quot;) } 결과 child1 Exception -&amp;gt; StandaloneCoroutine was cancelled parent coroutine child 2 coroutine child 3 coroutine main 하지만, 자식 코루틴에서 예외가 발생하면 그 예외는 최상위 부모 코루틴에 전달되어 모든 코루틴이 취소가 된다. 아래 예제는 child3에 예외를 발생시킨 것으로 먼저 부모 코루틴인 child2가 취소되고 다시 취소가 전파되어 부모 코루틴까지 취소가 됨으로써 child1도 취소가 되었다. 자식 코루틴 예외 발생 시 코드 import kotlinx.coroutines.* import java.io.IOException import kotlin.coroutines.cancellation.CancellationException fun main() = runBlocking { val job = CoroutineScope(Dispatchers.Default).launch { try { val child1 = launch { try { delay(3000) println(&quot;child1 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child1 Exception -&amp;gt; ${e.message}&quot;) } } val child2 = launch { try { val child3 = launch { try { throw IOException() // 예외 발생 delay(3000) println(&quot;child 3 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child3 Exception -&amp;gt; ${e.message}&quot;) } } delay(3000) println(&quot;child 2 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child2 Exception -&amp;gt; ${e.message}&quot;) } } delay(1000) println(&quot;parent coroutine&quot;) } catch (e: CancellationException) { println(&quot;parent Exception -&amp;gt; ${e.message}&quot;) } }.join() println(&quot;main&quot;) } 결과 child2 Exception -&amp;gt; StandaloneCoroutine is cancelling parent Exception -&amp;gt; StandaloneCoroutine is cancelling child1 Exception -&amp;gt; Parent job is Cancelling Exception in thread &quot;DefaultDispatcher-worker-4&quot; java.io.IOException at CehKt$main$1$job$1$child2$1$child3$1.invokeSuspend(ceh.kt:21) at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106) at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:570) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:749) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:677) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:664) Suppressed: kotlinx.coroutines.DiagnosticCoroutineContextException: [StandaloneCoroutine{Cancelling}@50074ae7, Dispatchers.Default] main 그렇다면 자식 코루틴에서 예외가 발생하더라도 부모에게 취소를 전파시키지 않는 방법은 무엇이 있을까?해답은 SupervisorJob 또는 supervisorScope을 이용하는 것이다. 이 두 개는 자식에서 예외가 발생하더라도 부모에게는 취소를 전파하지 않고 자식에게만 취소를 전파하게 된다. 먼저 SupervisorJob을 이용해 부모에게 취소를 전파시키지 않는 방법을 살펴보면 아래와 같다. SupervisorJob 코드 import kotlinx.coroutines.* import java.io.IOException import kotlin.coroutines.cancellation.CancellationException fun main() = runBlocking { val supervisorJob = SupervisorJob() // SupervisorJob 객체 생성 val job = CoroutineScope(Dispatchers.Default).launch { try { val child1 = launch { try { delay(3000) println(&quot;child1 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child1 Exception -&amp;gt; ${e.message}&quot;) } } val child2 = launch { try { val child3 = launch(supervisorJob) { // supervisorJob 객체 전달 try { throw IOException() // 예외 발생 delay(3000) println(&quot;child 3 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child3 Exception -&amp;gt; ${e.message}&quot;) } } delay(3000) println(&quot;child 2 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child2 Exception -&amp;gt; ${e.message}&quot;) } } delay(1000) println(&quot;parent coroutine&quot;) } catch (e: CancellationException) { println(&quot;parent Exception -&amp;gt; ${e.message}&quot;) } }.join() println(&quot;main&quot;) } 결과 Exception in thread &quot;DefaultDispatcher-worker-1&quot; java.io.IOException at CehKt$main$1$job$1$child2$1$child3$1.invokeSuspend(ceh.kt:22) at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106) at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:570) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:749) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:677) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:664) Suppressed: kotlinx.coroutines.DiagnosticCoroutineContextException: [StandaloneCoroutine{Cancelling}@3fb6433c, Dispatchers.Default] parent coroutine child1 coroutine child 2 coroutine main 위 예제에서 본 것처럼, child3에서 예외가 발생하더라도 launch메소드에 SupervisorJob을 전달함으로써 부모에게 취소가 전파되지 않도록 한다. 또한, child2에서 예외가 발생할 경우 부모에게 예외를 전달하지 않지만 child2의 자식 코루틴인 child3에는 취소를 전파함으로써 같이 단방향으로 취소를 전파한다는 것을 알 수 있다. 코드 import kotlinx.coroutines.* import java.io.IOException import kotlin.coroutines.cancellation.CancellationException fun main() = runBlocking { val supervisorJob = SupervisorJob() [...] val child2 = launch(supervisorJob) { try { val child3 = launch { try { delay(3000) println(&quot;child 3 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child3 Exception -&amp;gt; ${e.message}&quot;) } } throw IOException() // 예외 발생 delay(3000) println(&quot;child 2 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child2 Exception -&amp;gt; ${e.message}&quot;) } } delay(1000) println(&quot;parent coroutine&quot;) } catch (e: CancellationException) { println(&quot;parent Exception -&amp;gt; ${e.message}&quot;) } }.join() println(&quot;main&quot;) } 결과 child3 Exception -&amp;gt; Parent job is Cancelling Exception in thread &quot;DefaultDispatcher-worker-1&quot; java.io.IOException at CehKt$main$1$job$1$child2$1.invokeSuspend(ceh.kt:29) at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106) at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:570) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:749) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:677) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:664) Suppressed: kotlinx.coroutines.DiagnosticCoroutineContextException: [StandaloneCoroutine{Cancelling}@1b633969, Dispatchers.Default] parent coroutine child1 coroutine main 이렇게 되면 모든 자식 코루틴에 SupervisorJob을 전달해주어야 하는데, 자식 코루틴 개수가 많다면 일일히 다 전달해주기에는 조금 비효율적일 수 있다. 그럴 땐 supervisorScope을 사용할 수 있다. 단, supervisorScope안에 있는 자식 코루틴에만 적용되며 자식 코루틴의 자식 코루틴에서는 적용되지 않는다. supervisorScope 코드 import kotlinx.coroutines.* import java.io.IOException import kotlin.coroutines.cancellation.CancellationException fun main() = runBlocking { val job = CoroutineScope(Dispatchers.Default).launch { supervisorScope { try { val child1 = launch { try { throw IOException() // 예외 발생 delay(3000) println(&quot;child1 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child1 Exception -&amp;gt; ${e.message}&quot;) } } val child2 = launch { try { val child3 = launch { try { delay(3000) println(&quot;child 3 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child3 Exception -&amp;gt; ${e.message}&quot;) } } delay(3000) println(&quot;child 2 coroutine&quot;) } catch (e: CancellationException) { println(&quot;child2 Exception -&amp;gt; ${e.message}&quot;) } } delay(1000) println(&quot;parent coroutine&quot;) } catch (e: CancellationException) { println(&quot;parent Exception -&amp;gt; ${e.message}&quot;) } } }.join() println(&quot;main&quot;) } 결과 Exception in thread &quot;DefaultDispatcher-worker-2&quot; java.io.IOException at CehKt$main$1$job$1$1$child1$1.invokeSuspend(ceh.kt:11) at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106) at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:570) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:749) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:677) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:664) Suppressed: kotlinx.coroutines.DiagnosticCoroutineContextException: [StandaloneCoroutine{Cancelling}@104cb185, Dispatchers.Default] parent coroutine child 2 coroutine child 3 coroutine main supervisorScope는 내부적으로 부모 코루틴 scope의 coroutineContext를 상속받으며 이 컨텍스트의 Job을 SupervisorJob로 오버라이드하기 때문에 가능한 일이다. 아래는 supervisorScope에 대한 주석 내용이다. [참고] https://kotlinlang.org/docs/exception-handling.html" }, { "title": "Coroutine에서 Retrofit 사용 시 알아둘 점", "url": "/posts/Coroutine%EC%97%90%EC%84%9C-Retrofit-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EC%95%8C%EC%95%84%EB%91%98-%EC%A0%90/", "categories": "Android, TIP", "tags": "Android, Coroutine, Retrofit", "date": "2022-05-07 17:18:13 +0900", "snippet": "이전에 안드로이드 앱을 구현하면서 Coroutine에서 Retrofit을 사용한 적이 있었다. 그때 당시에는 인터넷 예제에서는 대부분 아래와 같이 구현되어 있었다.interface XXXService { @GET(&quot;api/YYYY&quot;) suspend fun getData(): Call&amp;lt;ZZZZ&amp;gt; // 또는 Response&amp;lt;ZZZZ&amp;gt;}그런데, 레트로핏 2.6.0 이상부터는 코틀린 전용 확장 함수를 지원함으로써 Call 또는 Response를 해줄 필요가 없다고 한다. 그 이유를 추측해보자면 코루틴을 사용하기 전에는 스레드에서 데이터를 UI로 보낼 때에는 콜백함수를 이용해서 메인 스레드에 전달 해주어야 하기 때문에 Call로 랩핑을 해주어야 하지만, 코루틴은 콜백함수 없이도 suspend 키워드가 있다면 Dispatchers.Main에서도 UI에서 실행할 수 있기 때문인 것 같다.만약 응답의 전체 데이터를 원한다면 Result&amp;lt;ZZZZ&amp;gt; 형식으로 사용 가능하다고 한다. 또한, 여러 인터넷에 있는 예제들을 보면 아래와 같이 구현된 것들도 가끔가다 볼 수 있었다.suspend fun getResult() { viewModelScope.launch { withContext(Dispatchers.IO) { val data = XXXService.getData() // ... } }}이또한 잘못 사용한 예로 볼 수 있다. 위에서 언급한 것과 비슷하지만, viewModelScope의 내부를 살펴보면 디스패처가 Dispatchers.Main.immediate로 되어있는 것을 알 수 있다.public val ViewModel.viewModelScope: CoroutineScope// ...CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)// ...즉, 어차피 디스패처가 Main으로 설정되어 있고, 위에서 언급한 것처럼 레트로핏은 코루틴 관련 확장 함수들(suspend)을 지원하도록 구현되었으므로 굳이 코루틴에서 withContext를 실행해줄 필요가 없다.아래는 구글 코드랩에 작성된 글을 가져왔다.내 생각코루틴에서 Dispatchers.IO는 네트워크 통신 등에서 사용될 수 있다고 하는데 아마 레트로핏을 이용하지 않고 HttpUrlConnection이나 다른 동기적으로 네트워크 통신을 하는 라이브러리를 이용해 직접 구현할 때를 의미하는 것 같기도 하다. 이 부분에 대해서는 좀 더 생각을 해봐야할 것 같다.[출처] https://developer.android.com/codelabs/kotlin-coroutines#8" }, { "title": "Coroutine 원리", "url": "/posts/Coroutine-%EC%9B%90%EB%A6%AC/", "categories": "Kotlin, Coroutine", "tags": "Kotlin, Coroutine", "date": "2022-05-06 15:18:24 +0900", "snippet": "최종 수정 날짜 : 2022-05-06 16:58:38 +0900Coroutine 원리코루틴이 어떻게 작동되는가에 대해 공부한 내용을 정리해보았다.이전 글을 참고해보면, 코루틴은 처음 생성될 때 사용한 스레드가 아닌 다른 스레드에서도 실행될 수 있다고 했다. 그게 가능한 이유는 아래 gif를 참고해보자.스레드에서 코루틴이 suspend 상태가 되면 해당 스레드는 다른 resume이 가능한 상태인 코루틴을 가지고 와서 실행한다. 그리고 suspend된 코루틴이 다시 resume 가능한 상태가 되면 다시 실행한다. 단, suspend된 코루틴이 다시 resume될 때 동일한 스레드에서 실행되지 않을 수 있다. 스레드는 다른 스레드를 실행할 때 context switching이 발생하게 되므로 오버헤드가 발생하지만, 코루틴에서는 사용하는 스레드 자체에서 실행가능한 다른 코루틴을 찾아 실행하기 때문에 스레드를 switch하는 작업을 하지 않아 오버헤드가 발생하지 않는다. 다른 Dispatcher로 변경하게 된다면 context switching이 발생할 수 있는데, withContext를 이용해 Dispatcher를 변경하게 되면 context switching을 최대한 방지한다고 한다.그럼 suspend와 resume이 어떤 방식으로 작동하는지에 대한 gif를 참고해보자.코루틴이 suspend될 때마다 함수와 변수를 추적하는데 사용하는 스택 프레임에 해당 코루틴에 대한 정보를 저장한다. 그리고 다시 resume될 때 해당 스택 프레임에서 코루틴에 대한 정보를 가지고와 다시 진행하게 된다. 메인 스레드에 있는 모든 코루틴이 suspend 상태가 되면 메인 스레드는 다른 작업을 할 수 있게 되어 UI를 업데이트하거나 사용자와 상호작용할 수 있게 된다.Dispatcher자주 사용하는 디스패처의 종류는 아래와 같다. Dispatchers.Main UI와 상호작용해야할 때 suspend 함수를 호출할 때 UI 관련 함수를 호출할 때 LiveData를 업데이트할 때 Dispatchers.IO 디스크 또는 네트워크 IO를 처리할 때 데이터베이스 파일 입/출력 네트워크 Dispatchers.Default CPU를 많이 사용하는 작업을 처리할 때 List 정렬 JSON 파싱 DiffUtils 먼저 Dispatchers.Default에 대해 알아보자. Dispatchers.Default launch나 async같은 코루틴 빌더에서 디스패처나 ContinuationInterceptor를 주지 않으면 기본적으로 적용된다. 기본적으로 이 디스패처가 사용하는 최대 병렬 처리는 CPU 코어 수와 동일하지만 최소 2개 이상이다. Dispatchers.Main UI와 관련된 작업을 진행할 때 사용할 수 있으며, 대체로 Single Thread로 작동된다. 이 디스패처는 직접적으로 사용하거나 MainScope 팩토리를 이용해 사용할 수 있다. Dispatchers.Main.immediate 안드로이드의 viewModelScope이나 lifecycleScope에서 사용하는 디스패처이다. 메인 스레드에서 즉시 실행하기 때문에 성능을 최적화할 수 있다. Dispatchers.IO 기본적으로 64개의 스레드 또는 코어 수 중 더 큰 수로 스레드 수가 제한된다. 이 디스패처는 Default 디스패처와 스레드를 공유하므로 withContext(Dispatchers.IO)를 사용하면 다른 스레드로 전환되지 않고 동일한 스레드에서 실행이 계속된다. [출처] https://en.wikipedia.org/wiki/Coroutine https://kotlinlang.org/docs/coroutines-basics.html https://play.kotlinlang.org/hands-on/Introduction%20to%20Coroutines%20and%20Channels/01_Introduction https://medium.com/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb https://medium.com/androiddevelopers/coroutines-on-android-part-ii-getting-started-3bff117176dd" }, { "title": "Coroutine", "url": "/posts/Coroutine/", "categories": "Kotlin, Coroutine", "tags": "Kotlin, Coroutine", "date": "2022-05-05 14:27:05 +0900", "snippet": "최종 작성 날짜 : 2022-05-05 21:10:35 +0900Coroutine코루틴이란?코루틴(Coroutine) 자체는 코틀린에 국한된 개념이 아닌 예전부터 알려진 개념이다. 코루틴의 이름은 Co + Routine이 합쳐져 불리는 것으로, Co는 together의 의미를 가지고 있으며 Routine은 함수라고 생각하면 된다. 즉, 코루틴은 routine들이 서로 상호작용하면서 실행되고, 실행을 일시정지(suspend)하고 다시 진행(resume)할 수 있는 비선점형 멀티태스킹을 위한 서브루틴(subroutine)을 의미한다. 비선점형 멀티태스킹 CPU를 사용하고 있는 스레드가 작업을 다 완료해야지만 운영체제에서 해당 자원을 회수할 수 있는 것을 의미한다.코루틴의 목적코루틴의 목적은 간단하다. 메인 스레드를 차단하기에는 너무 오래 걸리는 작업을 대신 처리하기 위함이다. 일반적인 함수에 suspend 키워드와 withContext를 이용해 코루틴의 실행을 다른 스레드로 쉽게 옮길 수 있다.suspend 키워드를 입력함으로써 코루틴 내에서만 해당 함수를 호출하도록 강제할 수 있다.구조적 동시성 (Structured concurrency)코루틴은 구조적 동시성의 원칙을 따른다. 하나의 부모 Scope안에 자식 Scope를 생성할 수 있는데, 자식 Scope에 있는 코드가 모두 실행이 완료(취소도 포함됨)되어야만 부모 Scope가 완료된다는 것이다. 이렇게 구조적 동시성을 지킨 잘 짜여진 코드는 관련된 모든 자식 코루틴이 취소되므로 작업 누수(Work leak)가 발생하지 않는다는 것이다. 작업 누수라는 것은 메모리 누수와 비슷하지만, 코루틴 자체를 잃어버리게 됨으로써 메모리 뿐만 아니라 CPU, Disk 등에도 누수가 발생하는 것을 의미한다.코루틴과 스레드의 차이코루틴은 다른 코드들과 동시에 실행된다는 점(비동기)에서 스레드랑 개념적으로는 비슷하지만 엄연히 다르다. 스레드는 운영체제에서 관리(선점형)하지만 코루틴은 프로그램 코드에서 관리한다. 또한, 스레드에서 작성된 코드는 해당 스레드에서만 실행이 가능하지만, 코루틴은 작성된 코드가 다른 스레드에서 실행이 가능하다. Thread 사용 시 코드 import kotlin.concurrent.thread fun log(message: String) = println(&quot;[${Thread.currentThread().name}] $message&quot;) fun main() { runThreads() } fun runThreads() { for (i in 1..5) { thread { log(&quot;$i 번째 스레드&quot;) Thread.sleep(3000) log(&quot;$i 번째 스레드 종료&quot;) } } } 결과 [Thread-3] 3 번째 스레드 [Thread-4] 4 번째 스레드 [Thread-2] 2 번째 스레드 [Thread-1] 1 번째 스레드 [Thread-5] 5 번째 스레드 [Thread-1] 1 번째 스레드 종료 [Thread-3] 3 번째 스레드 종료 [Thread-2] 2 번째 스레드 종료 [Thread-5] 5 번째 스레드 종료 [Thread-4] 4 번째 스레드 종료 위 결과에서 스레드 시작과 종료가 동일한 스레드에서 발생하는 것을 볼 수 있다. Coroutine 사용 시 코드 import kotlinx.coroutines.* fun log(message: String) = println(&quot;[${Thread.currentThread().name}] $message&quot;) fun main() = runBlocking { runCoroutine() delay(5000) } suspend fun runCoroutine() { for (i in 1..5) { CoroutineScope(Dispatchers.Default).launch { log(&quot;$i 번째 코루틴&quot;) delay(3000) log(&quot;$i 번째 코루틴 종료&quot;) } } } 결과 [DefaultDispatcher-worker-1] 1 번째 코루틴 [DefaultDispatcher-worker-2] 2 번째 코루틴 [DefaultDispatcher-worker-3] 3 번째 코루틴 [DefaultDispatcher-worker-3] 4 번째 코루틴 [DefaultDispatcher-worker-3] 5 번째 코루틴 [DefaultDispatcher-worker-1] 2 번째 코루틴 종료 [DefaultDispatcher-worker-3] 1 번째 코루틴 종료 [DefaultDispatcher-worker-3] 3 번째 코루틴 종료 [DefaultDispatcher-worker-3] 4 번째 코루틴 종료 [DefaultDispatcher-worker-3] 5 번째 코루틴 종료 위 결과를 보면 시작과 종료가 다른 스레드에서 발생한 것을 볼 수 있다. 코루틴의 장점코루틴을 사용하면 여러가지 이점이 있는데, 네트워크 통신을 예로들면 스레드는 통신이 완료됐을 때 결괏값을 콜백함수를 통해 전달해야한다. 하지만, 코루틴은 일시정지가 가능하므로 통신이 완료됐을 때 일반함수처럼 결괏값을 반환받아 다음 코드로 전달해 실행할 수 있다. 스레드에서 UI를 업데이트할 수 없으므로 invokeLater를 이용해 업데이트를 다른 스레드에서 할 수 있도록 했다. 아래 예시를 참고하자. Thread 사용 시 코드 import kotlinx.coroutines.runBlocking import javax.swing.SwingUtilities import kotlin.concurrent.thread fun log(message: String) = println(&quot;[${Thread.currentThread().name}] $message&quot;) fun loadImageThread(updateUI: (String) -&amp;gt; Unit) { thread { log(&quot;네트워크 통신중&quot;) Thread.sleep(3000) // 네트워크 통신 가정 updateUI(&quot;이미지를 가져왔습니다.&quot;) // UI 업데이트 } } fun main() = runBlocking { loadImageThread { // 콜백함수 등록 SwingUtilities.invokeLater { updateUI(it) } } log(&quot;main은 계속 실행됨&quot;) } fun updateUI(message: String) { log(message) } 결과 [main] main은 계속 실행됨 [Thread-1] 네트워크 통신중 [AWT-EventQueue-0] 이미지를 가져왔습니다. Coroutine 사용 시 코드 import kotlinx.coroutines.* fun log(message: String) = println(&quot;[${Thread.currentThread().name}] $message&quot;) suspend fun loadImageCoroutine(): String { withContext(Dispatchers.IO) { log(&quot;네트워크 통신중&quot;) delay(3000) // 네트워크 통신 가정 } return &quot;이미지를 불러왔습니다.&quot; } fun main() = runBlocking { launch { val message = loadImageCoroutine() updateUI(message) } log(&quot;main은 계속 실행됨&quot;) } fun updateUI(message: String) { log(message) } 결과 [main] main은 계속 실행됨 [DefaultDispatcher-worker-1] 네트워크 통신중 [main] 이미지를 불러왔습니다. 코루틴 관련 변수들 정리1. CoroutineScope vs coroutineScopeCoroutineScope과 coroutineScope은 C(대문자)와 c(소문자)의 한글자 차이지만 그 차이는 크다. 먼저 코드를 살펴보고 차이를 확인해보자. CoroutineScope 코드 import kotlinx.coroutines.* fun log(message: String) = println(&quot;[${Thread.currentThread().name}] $message&quot;) fun main() = runBlocking { var count = 0 CoroutineScope(Dispatchers.Default).launch { count = createNewCoroutine() log(&quot;result : $count&quot;) }.join() } suspend fun createNewCoroutine(): Int { var count = 0 CoroutineScope(Dispatchers.Default).launch { for (i in 1..20) { count++ delay(10) } } return count } 결과 [DefaultDispatcher-worker-1] result : 0 coroutineScope 코드 import kotlinx.coroutines.* fun main() = runBlocking { var count = 0 CoroutineScope(Dispatchers.Default).launch { count = createNewCoroutine() log(&quot;result : $count&quot;) }.join() } suspend fun createNewCoroutine(): Int { var count = 0 coroutineScope { for (i in 1..20) { count++ delay(10) } } return count } 결과 [DefaultDispatcher-worker-1] result : 20 위 코드에서 우리가 예상한 결괏값은 20이지만, 두 개의 결과는 다른것을 확인할 수 있다. CoroutineScope과 coroutineScope에 대한 설명은 아래와 같다. CoroutineScope 완전 새로운 코루틴을 위한 범위(Scope)를 코루틴 빌더(launch, async)와 Dispatcher를 이용해 정의할 수 있다. coroutineContext를 새로 생성해서 범위 안에 있는 다른 코루틴들을 모두 취소할 수도 있다. CoroutineScope를 이용해 코루틴을 생성하면 StandaloneCoroutine객체가 생성된다. 정확히는 코루틴 빌더 (launch)에 의해 새로운 코루틴이 생성되는 것이다. coroutineScope 범위(Scope)내에서 또다른 범위(Scope)를 실행하기 위해 사용하는 Scope Builder이다. 부모 Scope에 있는 coroutineContext를 상속받아 coroutineContext의 job을 재정의하며 이 scope안에 있는 다른 코루틴들을 모두 취소할 수도 있다. coroutineScope를 이용해 코루틴을 생성하면 ScopeCoroutine객체가 생성된다. CoroutineScope은 부모 코루틴 범위에 있더라도 부모 코루틴과 상관없는 아예 새로운 코루틴을 생성하기 때문에 일시정지가 되지 않고 바로 값을 반환해서 결괏값이 0이 출력되었으며, coroutineScope은 부모 코루틴의 범위 내에 있으므로 일시정지되어 작업을 수행한 후에 값을 반환하게 되므로 20이 출력되었다.2. coroutineContextcoroutineContext는 코루틴 빌더를 이용해 생성될 때 같이 생성되는 context이다. 이 coroutineContext를 이용해 자식 코루틴들을 관리할 수 있다. 위에서 언급한 것처럼 coroutineScope를 이용해 자식 코루틴을 만들게 되면 자식 코루틴은 부모 코루틴의 coroutineContext를 상속받아 사용한다. 일반적으로 이 context에 특별한 목적을 제외하고는 직접 접근하는 것을 추천하지 않는다.3. Scope buildercoroutineScope 또는 runBlocking을 이용해 자신만의 scope을 지정할 수 있으며 scope 내부에 있는 자식 코루틴들이 끝날때까지 완료되지 않는다. coroutineScope과 runBlocking이 둘 다 Scope builder이지만 둘의 차이점은 명확하다. coroutineScope은 현재 실행중인 스레드를 차단하지 않고 코루틴을 실행하지만, runBlocking은 현재 실행중인 스레드를 차단한 후 자식 코루틴들이 다 완료될 때까지 기다리고, 모두 완료가 되면 차단된 스레드를 다시 실행한다. 콘솔로 코루틴을 테스트할 때 main함수에 runBlocking을 설정하는 이유는 메인 스레드를 차단하지 않게 되면 코루틴이 실행되어도 프로그램이 종료되어 코루틴을 테스트할 수 없게 된다.또한, Scope builder안에 코루틴 빌더를 사용하여 부모가 있는 여러개의 코루틴을 생성할 수 있다.코드fun main() = runBlocking { val time = measureTimeMillis { doSomething() } println(&quot;main end [$time ms]&quot;)}suspend fun doSomething() { coroutineScope { launch { delay(2000) println(&quot;launch 2&quot;) } launch { delay(1000) println(&quot;launch 1&quot;) } println(&quot;coroutineScope&quot;) }}결과coroutineScopelaunch 1launch 2main end [2035 ms]4. Coroutine builder코루틴 빌더를 이용해 새로운 코루틴을 생성할 수 있으며, 코루틴 빌더에는 launch와 async 등이 있다. 이 코루틴 빌더를 이용해 새로운 코루틴을 생성할 수 있으며 독립적으로 작동한다. 3. Scope builder의 예시를 보면 알 수 있듯이, launch코루틴 빌더를 이용해 독립적으로 코루틴을 시작하고, coroutineScope에서는 자식 코루틴들이 모두 종료될 때까지 기다리게 되므로 처음 coroutineScope을 출력한 후 1초후에 launch 1이 출력되고, 다시 또 1초후에 launch 2가 호출된다. 그리고 모든 자식 코루틴이 종료됐으므로 coroutineScope이 종료된 후 메인 함수로 돌아가 main end를 호출하게 된다.launch와 async의 차이점은 반환값에 있다. launch는 Job이라는 객체로 반환을 하지만, async는 함수를 실행한 결괏값을 반환받을 수 있다. 즉, 함수 실행시 반환값을 받아야하는 경우 async로 코루틴을 생성하고 await 메소드로 결괏값을 받을 때까지 일시정지 상태를 유지한다.5. Dispatchers코루틴이 실행되는 위치를 지정할 수 있으며, Main, IO, Default가 존재한다. 기본적으로 안드로이드에서는 기본적으로 코루틴을 생성할 때 Dispatchers.Main을 사용하고 실행 위치를 변경해야할 때 withContext를 이용해 실행 위치를 변경한다. 각각 언제 사용해야되는지에 대해 살펴보면 아래와 같다. Dispatchers.Main UI와 상호작용해야할 때 suspend 함수를 호출할 때 UI 관련 함수를 호출할 때 LiveData를 업데이트할 때 Dispatchers.IO 디스크 또는 네트워크 IO를 처리할 때 데이터베이스 파일 입/출력 네트워크 Dispatchers.Default CPU를 많이 사용하는 작업을 처리할 때 List 정렬 JSON 파싱 DiffUtils 코드import kotlinx.coroutines.*import kotlin.system.measureTimeMillisfun log(message: String) = println(&quot;[${Thread.currentThread().name}] $message&quot;)fun main() = runBlocking { log(&quot;main start&quot;) val time = measureTimeMillis { doSomething() } log(&quot;main end [$time ms]&quot;)}suspend fun doSomething() { withContext(Dispatchers.IO) { launch { delay(2000) log(&quot;launch 2&quot;) } launch { delay(1000) log(&quot;launch 1&quot;) } log(&quot;coroutineScope&quot;) }}결과[main] main start[DefaultDispatcher-worker-1] coroutineScope[DefaultDispatcher-worker-3] launch 1[DefaultDispatcher-worker-3] launch 2[main] main end [2088 ms][출처] https://en.wikipedia.org/wiki/Coroutine https://kotlinlang.org/docs/coroutines-basics.html https://play.kotlinlang.org/hands-on/Introduction%20to%20Coroutines%20and%20Channels/01_Introduction https://medium.com/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb https://medium.com/androiddevelopers/coroutines-on-android-part-ii-getting-started-3bff117176dd" }, { "title": "코루틴 Job", "url": "/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-Job/", "categories": "Kotlin", "tags": "Kotlin", "date": "2022-05-02 13:40:24 +0900", "snippet": "최종 수정 날짜 : 2022-05-02 13:40:24 +0900Coroutine Job코루틴에서 Job은 백그라운드 작업의 단위를 의미하며 작업이 완료되거나 취소됐을 때 끝나는 생명주기(life-cycle)를 가지고 있다. Job을 인스턴스화하는 기본적인 방법은 아래와 같다. Coroutine job: launch 코루틴 빌더를 이용해 인스턴스 생성 CompletableJob: Job()의 생성자를 이용한 인스턴스 생성 Job()의 코드를 살펴보면 아래와 같다. public fun Job(parent: Job? = null): CompletableJob = JobImpl(parent) job은 기본적으로 결괏값을 반환하지 않지만, 결괏값을 반환하려면 async 코루틴 빌더와 같이 Deferred 를 사용해 결괏값을 받을 수도 있다.Job은 부모(Parent)/자식(Child) 관계가 있다.// 부모 (Parent)val parent = CoroutineScope(Dispatchers.Default).launch { [...] // 자식 (Child) val child = launch { [...] }}부모가 취소되거나 예외가 발생하면 하위 자식들도 동시에 종료가 되어 실행되지 않는다. 정상적으로 실행 시 정상실행 코드 import kotlinx.coroutines.* fun main() = runBlocking { CoroutineScope(Dispatchers.Default).launch { val job2 = launch { println(&quot;job2 start&quot;) delay(2000) println(&quot;Coroutine 2&quot;) } job2.join() println(&quot;Coroutine 1&quot;) }.join() println(&quot;Main&quot;) } 결과 job2 start Coroutine 2 Coroutine 1 Main 부모에서 예외 발생 시 예외발생 코드 import kotlinx.coroutines.* fun main() = runBlocking { CoroutineScope(Dispatchers.Default).launch { val job2 = launch { println(&quot;job2 start&quot;) delay(2000) println(&quot;Coroutine 2&quot;) } throw Exception() job2.join() println(&quot;Coroutine 1&quot;) }.join() println(&quot;Main&quot;) } 결과 부모에서 취소 발생 시 취소발생 코드 import kotlinx.coroutines.* import kotlin.coroutines.cancellation.CancellationException fun main() = runBlocking { CoroutineScope(Dispatchers.Default).launch { try { val job2 = launch { println(&quot;job2 start&quot;) delay(2000) println(&quot;Coroutine 2&quot;) } cancel() job2.join() println(&quot;Coroutine 1&quot;) } catch (e: CancellationException) { println(&quot;예외 : ${e.stackTraceToString()}&quot;) } }.join() println(&quot;Main&quot;) } 결과 자식이 취소가 될 경우에는 해당 Job만 취소되지만 CancellationException을 제외한 나머지 모든 예외는 부모까지 모두 종료가 된다. 자식에서 취소를 발생시킨 경우 코드 import kotlinx.coroutines.* import kotlin.coroutines.cancellation.CancellationException fun main() = runBlocking { CoroutineScope(Dispatchers.Default).launch { val job2 = launch { println(&quot;job2 start&quot;) // cancel() 또는 throw CancellationException() 시에도 취소가 됨 // throw CancellationException() // cancel() delay(2000) println(&quot;Coroutine 2&quot;) } job2.cancel() println(&quot;Coroutine 1&quot;) }.join() println(&quot;Main&quot;) } 결과 // job2만 취소가 됨 job2 start Coroutine 1 Main 자식에서 CancellationException이 아닌 다른 예외가 발생한 경우 코드 import kotlinx.coroutines.* fun main() = runBlocking { CoroutineScope(Dispatchers.Default).launch { val job2 = launch { println(&quot;job2 start&quot;) throw Exception() delay(2000) println(&quot;Coroutine 2&quot;) } job2.join() println(&quot;Coroutine 1&quot;) }.join() println(&quot;Main&quot;) } 결과 즉, 자식에서 CancellationException예외를 제외한 다른 예외가 발생할 경우 취소가 부모로 전파되고, 부모가 취소되면서 하위 모든 자식 코루틴이 종료된다.자식에서 예외가 발생해 부모의 Job까지 취소되는 것을 원하지 않는 경우 SupervisorJob을 이용해 예외가 발생한 Job만 취소할 수 있다. 단, 부모에서 SupervisorJob을 사용하더라도 하위 자식들의 job들은 취소가 된다.Job StatesJob에도 활성(Active), 완료(Complete), 취소(Cancel) 상태가 존재한다. 전체적인 상태 정보는 아래와 같다.보통, 일반적으로 사용할 경우 생성과 동시에 활성(Active)상태이지만 코루틴 빌더의 Start 파라미터에 CoroutineStart.LAZY 옵션을 줄 경우 join()또는 start() 메소드를 실행해야만 Job이 실행된다.코드 import kotlinx.coroutines.*fun main() = runBlocking { CoroutineScope(Dispatchers.Default).launch { val job2 = launch(start = CoroutineStart.LAZY) { println(&quot;job2 start&quot;) println(&quot;job state isActive: $isActive [job2 in]&quot;) delay(2000) println(&quot;Coroutine 2&quot;) } println(&quot;job state isActive: ${job2.isActive}&quot;) job2.join() println(&quot;Coroutine 1&quot;) }.join() println(&quot;Main&quot;)} 결과 job state isActive: falsejob2 startjob state isActive: true [job2 in]Coroutine 2Coroutine 1Main " }, { "title": "[프로그래머스] 프린터", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%94%84%EB%A6%B0%ED%84%B0/", "categories": "Programmers, Problems", "tags": "Programmers", "date": "2022-05-02 13:37:59 +0900", "snippet": "[프로그래머스] 프린터https://programmers.co.kr/learn/courses/30/lessons/42587문제풀이 현재 최대값을 다음값과 비교한다. 현재 최대값이 다음값보다 크거나 같으면 동시에 배포해야하므로 스택에서 꺼낸 후 1을 더해준다. 현재 최대값이 다음값보다 작다면 새롭게 배포해야 하므로 1을 push한 후 최대값을 변경한다. 반복import java.util.*;class Solution { public int[] solution(int[] progresses, int[] speeds) { Stack&amp;lt;Integer&amp;gt; releaseStack = new Stack(); int curMaxDay = 0; int releaseDay = 0; for (int i=0; i&amp;lt;progresses.length; i++) { releaseDay = (int)Math.ceil((100 - progresses[i]) / (double)speeds[i]); if (!releaseStack.isEmpty()) { if (curMaxDay &amp;gt;= releaseDay) { releaseStack.push(releaseStack.pop() + 1); } else { releaseStack.push(1); curMaxDay = releaseDay; } } else { releaseStack.push(1); curMaxDay = releaseDay; } } int[] answer = new int[releaseStack.size()]; for (int i=answer.length-1; i&amp;gt;=0; i--) { answer[i] = releaseStack.pop(); } return answer; }}" }, { "title": "Event Wrapper", "url": "/posts/Event-Wrapper/", "categories": "Android", "tags": "Android", "date": "2022-04-17 16:40:12 +0900", "snippet": "Event WrapperMVVM 아키텍처에서 View가 ViewModel을 참조하기 위한 방법 중 하나는 LiveData를 이용하는 것이다. ViewModel은 UI 데이터를 가지고 있기 때문에 화면 회전과 같은 변경 사항이 발생하더라도 View의 UI 데이터가 사라지지 않는다.그러나, Snackbar나 Toast, 화면 이동(navigation)과 같은 것들은 한 번만 사용되어야 한다. 예제 class MainActivity : AppCompatActivity() { private lateinit var button: Button private lateinit var viewModel: TestViewModel override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) viewModel = ViewModelProvider(this).get(TestViewModel::class.java) button = findViewById(R.id.button) button.setOnClickListener { viewModel.error(&quot;ERROR MESSAGE&quot;) } viewModel.errorMessage.observe(this) { Toast.makeText(this, it, Toast.LENGTH_SHORT).show() } }}class TestViewModel : ViewModel() { private val _errorMessage = MutableLiveData&amp;lt;String&amp;gt;() val errorMessage: LiveData&amp;lt;String&amp;gt; = _errorMessage fun error(msg: String) { _errorMessage.value = msg }} 위 코드는 버튼 클릭 시 뷰모델에 메시지를 전달하고, 메인 엑티비티에서 메시지를 Observe 하고 있다가 상태가 변경되면 토스트 메시지를 띄우는 간단한 코드이다. 그러나 자세히 보면 화면 회전시에도 한 번 더 Toast 메시지가 발생하게 되는 것을 확인할 수 있는데, 이는 ViewModel과 Activity의 Lifecycle을 알면 이해하기 쉽다. 간단히 말해서, 화면이 회전되면 Activity가 종료되었다가 다시 시작되고, LiveData를 Observe 하고있을 경우 최신 데이터를 가져오기 때문에 다시 Toast 메시지가 출력된다.그러나, Toast 메시지나 화면 이동같은 이벤트들은 화면이 회전되더라도 한 번만 발생해야하기 때문에 화면에 변경사항이 발생했을 경우 문제가 될 수 있다.한 번만 발생해야하는 이벤트들은 Event Wrapper를 이용해 관리해야한다.예제 class MainActivity : AppCompatActivity() { private lateinit var button: Button private lateinit var viewModel: TestViewModel override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) viewModel = ViewModelProvider(this).get(TestViewModel::class.java) button = findViewById(R.id.button) button.setOnClickListener { viewModel.error(&quot;ERROR MESSAGE&quot;) } viewModel.errorMessage.observe(this, EventObserver { Toast.makeText(this, it, Toast.LENGTH_SHORT).show() }) }}class TestViewModel : ViewModel() { private val _errorMessage = MutableLiveData&amp;lt;Event&amp;lt;String&amp;gt;&amp;gt;() val errorMessage: LiveData&amp;lt;Event&amp;lt;String&amp;gt;&amp;gt; = _errorMessage fun error(msg: String) { _errorMessage.value = Event(msg) }}open class Event&amp;lt;out T&amp;gt;(private val content: T) { var hasBeenHandled = false fun getContentIfNotHandled(): T? { return if (hasBeenHandled) { null } else { hasBeenHandled = true content } } fun peekContent(): T = content}class EventObserver&amp;lt;T&amp;gt;(private val onEventUnhandledContent: (T) -&amp;gt; Unit) : Observer&amp;lt;Event&amp;lt;T&amp;gt;&amp;gt; { override fun onChanged(event: Event&amp;lt;T&amp;gt;?) { event?.getContentIfNotHandled()?.let { onEventUnhandledContent(it) } }} 자세한 설명이나 예제는 아래 사이트를 참고https://medium.com/androiddevelopers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150" }, { "title": "[프로그래머스] 기능개발", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B8%B0%EB%8A%A5%EA%B0%9C%EB%B0%9C/", "categories": "Programmers, Problems", "tags": "Programmers", "date": "2022-04-16 16:33:25 +0900", "snippet": "[프로그래머스] 기능개발https://programmers.co.kr/learn/courses/30/lessons/42586 굳이 스택을 이용하지 않고도 풀 수 있는 문제문제풀이 현재 최대값을 다음값과 비교한다. 현재 최대값이 다음값보다 크거나 같으면 동시에 배포해야하므로 스택에서 꺼낸 후 1을 더해준다. 현재 최대값이 다음값보다 작다면 새롭게 배포해야 하므로 1을 push한 후 최대값을 변경한다. 반복import java.util.*;class Solution { public int[] solution(int[] progresses, int[] speeds) { Stack&amp;lt;Integer&amp;gt; releaseStack = new Stack(); int curMaxDay = 0; int releaseDay = 0; for (int i=0; i&amp;lt;progresses.length; i++) { releaseDay = (int)Math.ceil((100 - progresses[i]) / (double)speeds[i]); if (!releaseStack.isEmpty()) { if (curMaxDay &amp;gt;= releaseDay) { releaseStack.push(releaseStack.pop() + 1); } else { releaseStack.push(1); curMaxDay = releaseDay; } } else { releaseStack.push(1); curMaxDay = releaseDay; } } int[] answer = new int[releaseStack.size()]; for (int i=answer.length-1; i&amp;gt;=0; i--) { answer[i] = releaseStack.pop(); } return answer; }}" }, { "title": "[프로그래머스] 위장", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9C%84%EC%9E%A5/", "categories": "Programmers, Problems", "tags": "Programmers", "date": "2022-04-10 00:04:12 +0900", "snippet": "[프로그래머스] 위장https://programmers.co.kr/learn/courses/30/lessons/42578풀이방법 HashMap을 이용해 풀이 다른 옷들을 입을 조합의 개수를 알아야 함 예시1 설명 headgear 종류에서 의상 이름은 2가지이며 yellow_hat, green_turban, X 3가지의 경우의 수 존재 eyewear 종류에서 의상 이름은 1가지이며 bluesunglasses, X 2가지의 경우의 수 존재 결국 총 경우의 수는 3 * 2 = 6가지 그러나 문제 조건에 최소 1개의 의상은 입는다고 하였으므로 둘 다 입지 않은 X는 빼야하므로 -1 import java.util.HashMap;import java.util.Map;class Solution { public int solution(String[][] clothes) { int answer = 1; Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for(int i=0; i&amp;lt;clothes.length; i++) { map.put(clothes[i][1], map.getOrDefault(clothes[i][1], 0) + 1); } for(Map.Entry&amp;lt;String, Integer&amp;gt; entry : map.entrySet()) { answer *= (entry.getValue() + 1); } return answer - 1; }}" }, { "title": "Generics", "url": "/posts/Generics/", "categories": "Kotlin", "tags": "Kotlin", "date": "2022-03-30 17:32:27 +0900", "snippet": "최종 수정 날짜 : 2022-03-30 17:32:45 +0900Generics 제네릭(Generic)은 타입이 정해져있지 않은 클래스나 함수를 의미하며, 클래스가 인스턴스화 될 때 타입이 확정된다. 다양한 타입(자료형)을 다룰 수 있기 때문에 컬렉션에서 자주 사용한다. 컬렉션 : List, Map, 등.. class Number&amp;lt;T&amp;gt;(private val value: T) { fun getType() { println(value!!::class.java.typeName) }}fun main() { val number = Number&amp;lt;Double&amp;gt;(3.0) number.getType() val number2 = Number(10) number2.getType() val number3 = Number&amp;lt;Boolean&amp;gt;(true) number3.getType()}// 결과 // java.lang.Double// java.lang.Integer// java.lang.Boolean 제네릭 타입의 클래스를 생성하기 위해서는 단순히 클래스 뒤에 &amp;lt;타입&amp;gt; 형태를 취해 생성할 수 있다. 위 예제의 number2 변수를 보면 따로 타입을 설정하지 않았는데, 이는 컴파일러가 유추할 수 있는 값이 생성자로 들어갔기 때문에 제거가 가능하다. 제네릭에서 사용하는 형식 매개변수 이름은 아래와 같다. 아래 이름들을 사용해야한다는 강제성은 없지만 일종의 규칙처럼 사용되기 때문에 알아두면 좋다. 매개변수 이름 의미 E 요소 (Element) K 키 (Key) N 숫자 (Number) T 형식 (Type) V 값 (Value) R 리턴 (Return) 제네릭 함수 및 메소드 제네릭 함수는 아래와 같이 사용된다.fun &amp;lt;T&amp;gt; find(a: Array&amp;lt;T&amp;gt;, target: T): Int {}fun main() { val array1 = arrayOf(&quot;Apple&quot;, &quot;Banana&quot;) val array2 = arrayOf(1, 2, 3) println(find&amp;lt;String&amp;gt;(array1, &quot;Banana&quot;)) println(find(array2, 2))}// 결과// 1// 1 코틀린에서 사용하는 제네릭 함수들을 살펴본 결과 대부분 파일의 최상위에서 위와 같이 선언함을 알 수 있었다. 최상위 : 어떤 클래스에도 속해있지 않은 함수 또는 메소드 제네릭 클래스에서는 매개변수 이름(E, K, N, T, V 등)을 전달받기 때문에 위와 같이 제네릭 함수를 쓸 필요는 없지만, 최상위에 있는 제네릭 함수 또는 메소드에는 위처럼 fun 키워드 앞에 타입을 설정해주어야 하는 것으로 판단할 수 있다. 제네릭 클래스와 마찬가지로 find 제네릭 함수 뒤에 값을 유추할 수 있다면 &amp;lt;타입&amp;gt;을 제거해서 사용이 가능하다.타입 제한하기 제네릭으로 구현하게 되면 실수든 고의든 의도하지 않은 타입을 사용하게 될 수도 있다. 간단한 계산기로 예시를 들어보면 아래와 같다. 제네릭 함수나 메서드, 클래스에서는 연산(+, -, *, /)등을 수행할 수 없기 때문에 람다식으로 연산 후 전달하는 방법을 사용한다. 수행이 불가능한 이유는 자료형을 추론할 수 없기 때문이다. class Calculator&amp;lt;T&amp;gt; { fun add(a: T, b: T, op: (T, T) -&amp;gt; T): T { return op(a, b) }}fun main() { val calculator = Calculator&amp;lt;Int&amp;gt;() val data = calculator.add(10, 20) { a, b -&amp;gt; a + b } println(data) val calculator2 = Calculator&amp;lt;String&amp;gt;() val data2 = calculator2.add(&quot;a&quot;, &quot;b&quot;) { a, b -&amp;gt; a + b } println(data2)}// 결과// 30// ab 우리가 생각하고 의도하는 계산기는 숫자를 더한 결괏값만 원하지만, 위와 같이 String 타입으로 제네릭 클래스를 인스턴스화 하더라도 막을 방법이 없다. 이럴 때 숫자만 가능하도록 제약조건을 걸 수 있다. class Calculator&amp;lt;T: Number&amp;gt; { fun add(a: T, b: T, op: (T, T) -&amp;gt; T): T { return op(a, b) }}fun main() { val calculator = Calculator&amp;lt;Int&amp;gt;() val data = calculator.add(10, 20) { a, b -&amp;gt; a + b } println(data) val calculator2 = Calculator&amp;lt;String&amp;gt;() // &amp;lt;--- 오류 발생 val data2 = calculator2.add(&quot;a&quot;, &quot;b&quot;) { a, b -&amp;gt; a + b } println(data2)}특정 조건으로 타입 제한하기 (Where) 제네릭 타입으로 특정 조건을 만족하는 타입만 받고싶을 수 있다. 그럴 때 Where 키워드를 사용해 제한할 수 있다.package genericsinterface InterfaceAinterface InterfaceBclass ImplA : InterfaceA, InterfaceBclass ImplB : InterfaceAfun &amp;lt;T&amp;gt; someFunction(): Int where T: InterfaceA, T: InterfaceB { return 10}fun main() { val implA = ImplA() val implB = ImplB() someFunction&amp;lt;ImplA&amp;gt;() someFunction&amp;lt;ImplB&amp;gt;() // &amp;lt;--- 오류 발생} 위 코드는 간단히 InterfaceA, InterfaceB를 상속받은 ImplA 클래스와 InterfaceA만 상속받은 ImplB 클래스를 이용해 someFunction 제네릭 함수를 이용하려고 한 결과이다. 예시에서 볼 수 있듯이 where 키워드로 InterfaceA와 InterfaceB를 상속받은 클래스만 허용하기 때문에 메인 함수의 두 번째 someFunction에서 에러가 발생하는 것을 알 수 있다.가변성(Variance)의 유형 기본적으로 제네릭에서는 클래스 간의 상/하위 개념이 존재하지 않는다.open class Parentclass Child : Parent()class Box&amp;lt;T&amp;gt;fun main() { val value1: Parent = Child() // &amp;lt;--- 가능 val value2: Box&amp;lt;Parent&amp;gt; = Box&amp;lt;Child&amp;gt;() // &amp;lt;--- 불가능 // 에러 내용 // 타입이 일치하지 않습니다. // 필요 항목: // Box&amp;lt;Parent&amp;gt; // 발견된 항목: // Box&amp;lt;Child&amp;gt;} 위 예시처럼 Child 클래스는 Parent 클래스의 모든 기능을 가지고 있으므로 선언이 가능(value1)하지만, 이것을 제네릭으로 표현(value2)하면 에러가 발생한다. 따라서 상/하위의 값을 클래스와 동일하게 사용하기 위해서는 가변성의 유형에 대해서 알아야 한다. 가변성의 유형은 아래와 같다. 공변성(Convariance) : T’가 T의 하위 자료형이면, Box&amp;lt;T’&amp;gt;는 Box의 하위 자료형이다. (out) 반공변성(Contravariance) : T’가 T의 하위 자료형이면 Box는 Box&amp;lt;T&#39;&amp;gt;의 하위 자료형이다. (in) 무변성(Invariance) : Box와 Box&amp;lt;T&#39;&amp;gt;는 관계가 없다. 가변성의 관계를 다이어그램으로 나타내면 아래와 같다. 무변성(Invariance) 위 예시의 value2가 무변성에 해당한다. 타입에 in이나 out으로 공변성 또는 반공변성을 선언하지 않을 경우 무변성으로 선언되어 상하관계와 상관없이 자료형 불일치가 발생한다.공변성(Convariance) 예를 들어서 Int가 Any의 하위 자료형이므로 제네릭 타입 T에 대해 공변적이라고 한다.class Box&amp;lt;out T&amp;gt;()fun main() { val anys: Box&amp;lt;Any&amp;gt; = Box&amp;lt;Int&amp;gt;() val nothings: Box&amp;lt;Nothing&amp;gt; = Box&amp;lt;Int&amp;gt;() // &amp;lt;--- 에러 발생} Int는 Any의 하위 자료형이므로 제네릭 클래스에 out 키워드를 선언해서 공변성을 적용할 수 있다. 그러나 Int가 Nothing의 하위 타입이 아니므로 에러가 발생한다. public class Nothing private constructor() 반공변성(Contravariance) 공변성의 상/하위 관계가 반대가 된다.class Box&amp;lt;in T&amp;gt;()fun main() { val anys: Box&amp;lt;Any&amp;gt; = Box&amp;lt;Int&amp;gt;() // &amp;lt;--- 에러 발생 val nothings: Box&amp;lt;Nothing&amp;gt; = Box&amp;lt;Int&amp;gt;()} Any는 Int의 하위 자료형이 아니므로 에러가 발생한다. 그러나 Nothing은 Int의 하위 자료형이므로 in 키워드를 적용해 반공변성을 적용할 수 있다. TODO reified 정리 프로젝션 가변성 예제 더 확인해보기 [참고] https://kotlinlang.org/docs/generics.html Do It! 코틀린 프로그래밍 책 " }, { "title": "[BOJ 2468] 안전 영역", "url": "/posts/2468-%EC%95%88%EC%A0%84-%EC%98%81%EC%97%AD/", "categories": "BOJ, Problems", "tags": "BOJ", "date": "2022-03-30 01:21:01 +0900", "snippet": "안전 영역 (2468번)https://www.acmicpc.net/problem/2468풀이방법 1~100까지 물의 높이가 될 수 있지만 입력값의 최대값을 최대 가능한 물의 높이로 생각한다. 0부터 최대값까지 반복하면서 map의 (0, 0)부터 bfs로 탐색한다.import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;public class Main { static int n = 0; static int[][] map = null; static boolean[][] visited = null; static int max = 0; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); n = Integer.parseInt(br.readLine()); map = new int[n][n]; int maxNumber = 0; for (int i=0; i&amp;lt;n; i++) { StringTokenizer st = new StringTokenizer(br.readLine()); for (int j=0; j&amp;lt;n; j++) { int tmp = Integer.parseInt(st.nextToken()); maxNumber = Math.max(maxNumber, tmp); map[i][j] = tmp; } } for (int water=0; water&amp;lt;maxNumber; water++) { int count = 0; visited = new boolean[n][n]; for (int j = 0; j &amp;lt; n; j++) { for (int k = 0; k &amp;lt; n; k++) { if (!visited[j][k] &amp;amp;&amp;amp; map[j][k] &amp;gt; water) { bfs(k, j, water); count++; } } } max = Math.max(max, count); } System.out.println(max); } static Queue&amp;lt;int[]&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); static int[] directX = {1, 0, -1, 0}; static int[] directY = {0, 1, 0, -1}; private static void bfs(int x, int y, int maxNumber) { queue.add(new int[] { x, y }); while (!queue.isEmpty()) { int[] pos = queue.poll(); int curX = pos[0]; int curY = pos[1]; for (int i=0; i&amp;lt;4; i++) { int dx = curX + directX[i]; int dy = curY + directY[i]; if (dx &amp;lt; 0 || dx &amp;gt;= n || dy &amp;lt; 0 || dy &amp;gt;= n || visited[dy][dx]) continue; if (map[dy][dx] &amp;gt; maxNumber) { queue.add(new int[]{dx, dy}); visited[dy][dx] = true; } } } }}" }, { "title": "[프로그래머스] 전화번호 목록", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8-%EB%AA%A9%EB%A1%9D/", "categories": "Programmers, Problems", "tags": "Programmers", "date": "2022-03-29 22:49:39 +0900", "snippet": "[프로그래머스] 전화번호 목록https://programmers.co.kr/learn/courses/30/lessons/42577풀이방법 효율성을 위해 정렬을 먼저 수행 “12”, “132”, “125”, “1234”를 정렬하면 “12”, “1234”, “125”, “132”가 되므로 다음 위치의 값이 현재 위치의 값으로 시작하게 될 경우 false 반환import java.util.Arrays;class Solution { public boolean solution(String[] phone_book) { Arrays.sort(phone_book); for (int i=0; i&amp;lt;phone_book.length-1; i++) { if (phone_book[i+1].indexOf(phone_book[i]) == 0) { return false; } } return true; }}시행착오 처음에는 무난하게 2중 for문으로 작성했으나 효율성에서 탈락했다." }, { "title": "[프로그래머스] 완주하지 못한 선수", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%99%84%EC%A3%BC%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%9C-%EC%84%A0%EC%88%98/", "categories": "Programmers, Problems", "tags": "Programmers", "date": "2022-03-29 22:18:03 +0900", "snippet": "[프로그래머스] 완주하지 못한 선수https://programmers.co.kr/learn/courses/30/lessons/42576풀이방법 HashMap을 이용해 풀이 동일 이름이 있을 수 있다고 했으므로 참가자의 값들이 이미 HashMap에 있을 경우에는 value를 가져와 +1 완주자의 경우 HashMap에 해당 키값을 찾아 -1 결국 0이 되지 않는 키값이 미완주자이므로 출력import java.util.HashMap;import java.util.Map;class Solution{ public String solution(String[] participant, String[] completion) { String answer = &quot;&quot;; Map&amp;lt;String, Integer&amp;gt; hmParticipant = new HashMap&amp;lt;String, Integer&amp;gt;(); for (String p : participant) { hmParticipant.put(p, (int)hmParticipant.getOrDefault(p, 0) + 1); } for (String c : completion) { hmParticipant.put(c, (int)hmParticipant.getOrDefault(c, 0) - 1); } for(Map.Entry&amp;lt;String, Integer&amp;gt; entry : hmParticipant.entrySet()) { if (entry.getValue() &amp;gt; 0) { answer = entry.getKey(); break; } } return answer; }}" }, { "title": "LiveData", "url": "/posts/LiveData/", "categories": "Android", "tags": "Android", "date": "2022-03-29 18:54:24 +0900", "snippet": "LiveData LiveData는 액티비티나 프래그먼트의 Lifecycle을 고려한 옵저버 패턴을 이용해 구현된 데이터 홀더 클래스이다. 액티비티나 프래그먼트의 생명주기인 STARTED, RESUMED 상태에서만 데이터의 변경사항을 관찰자에게 알려주며, 그 외의 상태에서는 변경사항을 알리지 않는다. 즉, Active 상태에서만 변경사항을 관찰자에게 알려준다. 액티비티나 프래그먼트에서 LiveData를 observe 메소드를 이용해 관찰한다. 대체로 LiveData는 ViewModel에서 자주 사용된다. 화면 회전과 같은 변경사항이 발생했을 경우 액티비티는 Destory 됐다가 다시 Create되는데 이때 UI를 다시 그리게 되어 이전에 작성된 사항들이 사라지기 때문에 ViewModel 객체에서 UI의 데이터(텍스트 뷰 내용 등)를 관리한다. 액티비티나 프래그먼트에서 LiveData를 observe하고 있고 비활성 상태(홈버튼을 눌러 화면을 나갔을 때 등)에서 활성 상태로 변경될 때 LiveData의 최신 데이터값을 가져와 UI에 표현한다. 액티비티나 프래그먼트의 생명주기를 따르므로 화면이 Destory될 때 LiveData를 관찰하는 관찰자를 제거해주게 되어 메모리 누수에 대한 부작용을 제거할 수 있다.예제 1 class를 이용한 LiveData 예제activity_main.xml &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;EditText android:id=&quot;@+id/username_edittext&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; tools:text=&quot;가나다&quot; /&amp;gt; &amp;lt;Button android:id=&quot;@+id/add_user_button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;추가&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@id/username_edittext&quot; /&amp;gt;&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt; MainActivity.kt import androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.util.Logimport android.widget.Buttonimport android.widget.EditTextimport androidx.fragment.app.Fragmentimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.Observerconst val TAG = &quot;MainActivity&quot;class MainActivity : AppCompatActivity() { private lateinit var usernameEditText: EditText private lateinit var addUserButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val userList = UserList() usernameEditText = findViewById(R.id.username_edittext) addUserButton = findViewById&amp;lt;Button?&amp;gt;(R.id.add_user_button).apply { setOnClickListener { userList.addUser(usernameEditText.text.toString()) } } userList.userList.observe(this, Observer { users -&amp;gt; Log.d(TAG, &quot;================================&quot;) users.forEach { user -&amp;gt; Log.d(TAG, &quot;user info : $user&quot;) } Log.d(TAG, &quot;================================&quot;) }) }}data class User(val username: String)class UserList { private val totalUserList = mutableListOf&amp;lt;User&amp;gt;() private var _userList = MutableLiveData&amp;lt;List&amp;lt;User&amp;gt;&amp;gt;() val userList: LiveData&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; get() = _userList fun addUser(username: String) { totalUserList.add(User(username)) _userList.value = totalUserList }} 예제 2 ViewModel과 LiveData를 이용한 예제 예제 1과 동일한 xmlUserListViewModel.kt import androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelclass UserListViewModel : ViewModel() { private val totalUserList = mutableListOf&amp;lt;User&amp;gt;() private var _userList = MutableLiveData&amp;lt;List&amp;lt;User&amp;gt;&amp;gt;() val userList: LiveData&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; get() = _userList fun addUser(username: String) { totalUserList.add(User(username)) _userList.value = totalUserList }}data class User(val username: String) MainActivity.kt import androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.util.Logimport android.widget.Buttonimport android.widget.EditTextimport androidx.lifecycle.Observerimport androidx.lifecycle.ViewModelProviderconst val TAG = &quot;MainActivity&quot;class MainActivity : AppCompatActivity() { private lateinit var usernameEditText: EditText private lateinit var addUserButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val userListViewModel = ViewModelProvider(this).get(UserListViewModel::class.java) usernameEditText = findViewById(R.id.username_edittext) addUserButton = findViewById&amp;lt;Button&amp;gt;(R.id.add_user_button).apply { setOnClickListener { userListViewModel.addUser(usernameEditText.text.toString()) } } userListViewModel.userList.observe(this, Observer { users -&amp;gt; Log.d(TAG, &quot;================================&quot;) users.forEach { user -&amp;gt; Log.d(TAG, &quot;user info : $user&quot;) } Log.d(TAG, &quot;================================&quot;) }) }} " }, { "title": "ViewModel", "url": "/posts/ViewModel/", "categories": "Android", "tags": "Android", "date": "2022-03-20 15:36:43 +0900", "snippet": "작성중..ViewModel ViewModel은 View의 Lifecycle을 고려해 UI와 관련된 데이터들을 저장하고 관리하는 클래스이다. 따라서, 화면 전환과 같은 변경 사항(UI를 다시 그리는 등)이 발생할 경우에도 데이터를 유지시켜준다. 화면 전환이나 멀티 윈도우 모드로 들어갈 경우 액티비티나 프래그먼트는 onDestroy 콜백을 실행한 후에 다시 UI를 그리를 작업을 진행하므로 기존에 있던 데이터가 사라진다. onSaveInstanceState()를 사용해 UI 데이터를 저장하기 위해서는 데이터가 크지 않고, 직렬화 후 역직렬화를 할 수 있는 데이터만 사용해야 한다. UI의 목적은 데이터를 표시하거나 사용자의 이벤트에 반응하는 등을 처리하기 위함이므로 UI에 과도한 책임이 할당되면 클래스의 부피가 커지기 때문에 분리할 필요가 있다. UI 로직에서 View의 데이터를 ViewModel에 보관하도록 책임을 할당해야 한다. ViewModel은 View, Lifecycle 또는 액티비티의 Context를 참조를 포함하는 클래스를 참조하면 안된다." }, { "title": "적응형 아이콘 (Adaptive Icon)", "url": "/posts/%EC%A0%81%EC%9D%91%ED%98%95-%EC%95%84%EC%9D%B4%EC%BD%98-(Adaptive-Icon)/", "categories": "Android", "tags": "Android", "date": "2022-03-18 02:01:28 +0900", "snippet": "적응형 아이콘 (Adaptive Icon) API 26 (Android 8.0) 이상부터 사용가능함 전경(foreground), 배경(background), OEM Mask 레이어들로 아이콘을 구성함 전경 : 실제 아이콘 배경 : 아이콘 뒤의 배경 이미지 OEM Mask : 핸드폰 제작사마다 아이콘을 어떻게 표현해줄지에 대한 레이어 리소스 매니저에서 적응형 아이콘을 추가해준 후 프로젝트에 drawable-anydpi-v26 리소스 폴더를 생성한다. -v24, drawable에 있는 적응형 아이콘에 필요한 것들을 drawable-anydpi-v26 에 옮겨 쉽게 관리할 수 있다. 적응형 아이콘을 사용해야하는 이유 해상도에 따라 유연하게 변경되므로 기존처럼 따로 해상도별로 아이콘을 제작하지 않아도 된다. 그러나 API 26 이상에서만 가능하다는 점. 아이콘은 108dp의 크기로 제작해야하며 safe zone 내에 표현할 실제 아이콘(전경)이 위치해야 함 safe zone 이란 위에서 언급한 OEM Mask가 제작사별로 다른데 저 safe zone 안에 위치하기만 하면 어느 기기에서든 아이콘을 의미있게 표현할 수 있음. safe zone 은 위 사진에서 아이콘 주변에 동그라미 부분이 됨 " }, { "title": "안드로이드 Theme 변경하기", "url": "/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-Theme-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0/", "categories": "Android", "tags": "Android", "date": "2022-03-15 09:47:35 +0900", "snippet": "최종 업데이트 : 2022-03-15 09:47:35 +0900안드로이드 Theme 변경하기 Theme은 우리나라에서는 테마라고 부르고 영어권에서는 띰? 이라고 부른다. theme은 각각의 뷰 뿐만 아니라 앱, 액티비티, 뷰 계층에 적용되는 스타일의 집합이다. 하위 뷰에도 동일한 스타일이 적용되며 뷰가 아닌 상태바, 윈도우 백그라운드 등에도 적용된다. theme을 적용하는 이유는 시스템에 일관성 있는 디자인을 보여주기 위함이다. 테마의 색상을 변경할 때 Color Tool를 참고하여 수정할수도 있다. 내가 만드는 것보다 Material 팀에서 제공해주는걸 이용하는게 심적으로 편할 것 같다. 현재 앱의 Theme 확인하기 app -&amp;gt; res -&amp;gt; values -&amp;gt; themes.xml에 들어가면 현재 theme의 색상들을 볼 수 있다.&amp;lt;style name=&quot;Theme.Example&quot; parent=&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;&amp;gt; 위 xml코드의 의미는 이 theme의 이름은 Theme.Example이며 Example은 대게 앱의 이름을 나타낸다. theme에서는 클래스와 동일하게 상속 구조를 가지고 있다. 따라서 DarkActionBar를 상속받아 하위 theme에서 필요한 부분을 재구현하고 구현하지 않은 부분은 상위 theme을 이용하게 된다. 예시로 아래 코드는 상위 DarkActionBar의 colorPrimary를 재정의해주고 있는 것이다. &amp;lt;item name=&quot;colorPrimary&quot;&amp;gt;@color/purple_500&amp;lt;/item&amp;gt; 현재 앱 테마 변경하기 Color Tool 사이트를 참고하여 나는 정열적인 빨간색과 핑크핑크를 선택해서 아래와 같이 적용했다. colors.xml &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;resources&amp;gt; &amp;lt;color name=&quot;purple_200&quot;&amp;gt;#FFBB86FC&amp;lt;/color&amp;gt; &amp;lt;color name=&quot;purple_500&quot;&amp;gt;#FF6200EE&amp;lt;/color&amp;gt; &amp;lt;color name=&quot;purple_700&quot;&amp;gt;#FF3700B3&amp;lt;/color&amp;gt; &amp;lt;color name=&quot;teal_200&quot;&amp;gt;#FF03DAC5&amp;lt;/color&amp;gt; &amp;lt;color name=&quot;teal_700&quot;&amp;gt;#FF018786&amp;lt;/color&amp;gt; &amp;lt;color name=&quot;black&quot;&amp;gt;#FF000000&amp;lt;/color&amp;gt; &amp;lt;color name=&quot;white&quot;&amp;gt;#FFFFFFFF&amp;lt;/color&amp;gt; &amp;lt;color name=&quot;red&quot;&amp;gt;#FFD50000&amp;lt;/color&amp;gt; &amp;lt;color name=&quot;red_light&quot;&amp;gt;#FFFF5131&amp;lt;/color&amp;gt; &amp;lt;color name=&quot;red_dark&quot;&amp;gt;#FF9B0000&amp;lt;/color&amp;gt; &amp;lt;color name=&quot;pink&quot;&amp;gt;#FFF48FB1&amp;lt;/color&amp;gt; &amp;lt;color name=&quot;pink_light&quot;&amp;gt;#FFFFC1E3&amp;lt;/color&amp;gt; &amp;lt;color name=&quot;pink_dark&quot;&amp;gt;#FFBF5F82&amp;lt;/color&amp;gt;&amp;lt;/resources&amp;gt; themes.xml &amp;lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot;&amp;gt; &amp;lt;!-- Base application theme. --&amp;gt; &amp;lt;style name=&quot;Theme.Example&quot; parent=&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;&amp;gt; &amp;lt;!-- Primary brand color. --&amp;gt; &amp;lt;item name=&quot;colorPrimary&quot;&amp;gt;@color/red&amp;lt;/item&amp;gt; &amp;lt;item name=&quot;colorPrimaryVariant&quot;&amp;gt;@color/red_dark&amp;lt;/item&amp;gt; &amp;lt;item name=&quot;colorOnPrimary&quot;&amp;gt;@color/white&amp;lt;/item&amp;gt; &amp;lt;!-- Secondary brand color. --&amp;gt; &amp;lt;item name=&quot;colorSecondary&quot;&amp;gt;@color/pink&amp;lt;/item&amp;gt; &amp;lt;item name=&quot;colorSecondaryVariant&quot;&amp;gt;@color/pink_dark&amp;lt;/item&amp;gt; &amp;lt;item name=&quot;colorOnSecondary&quot;&amp;gt;@color/black&amp;lt;/item&amp;gt; &amp;lt;!-- Status bar color. --&amp;gt; &amp;lt;item name=&quot;android:statusBarColor&quot; tools:targetApi=&quot;l&quot;&amp;gt;?attr/colorPrimaryVariant&amp;lt;/item&amp;gt; &amp;lt;!-- Customize your theme here. --&amp;gt; &amp;lt;/style&amp;gt;&amp;lt;/resources&amp;gt; 다크테마 적용하기 다크테마에서는 light에서 설정한 색보다 밝은 색을 사용한다고 한다. &amp;lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot;&amp;gt; &amp;lt;!-- Base application theme. --&amp;gt; &amp;lt;style name=&quot;Theme.Example&quot; parent=&quot;Theme.MaterialComponents.DayNight. DarkActionBar&quot;&amp;gt; &amp;lt;!-- Primary brand color. --&amp;gt; &amp;lt;item name=&quot;colorPrimary&quot;&amp;gt;@color/red&amp;lt;/item&amp;gt; &amp;lt;item name=&quot;colorPrimaryVariant&quot;&amp;gt;@color/red_light&amp;lt;/item&amp;gt; &amp;lt;item name=&quot;colorOnPrimary&quot;&amp;gt;@color/black&amp;lt;/item&amp;gt; &amp;lt;!-- Secondary brand color. --&amp;gt; &amp;lt;item name=&quot;colorSecondary&quot;&amp;gt;@color/pink_light&amp;lt;/item&amp;gt; &amp;lt;item name=&quot;colorSecondaryVariant&quot;&amp;gt;@color/pink_light&amp;lt;/item&amp;gt; &amp;lt;item name=&quot;colorOnSecondary&quot;&amp;gt;@color/black&amp;lt;/item&amp;gt; &amp;lt;!-- Status bar color. --&amp;gt; &amp;lt;item name=&quot;android:statusBarColor&quot; tools:targetApi=&quot;l&quot;&amp;gt;?attr/ colorPrimaryVariant&amp;lt;/item&amp;gt; &amp;lt;!-- Customize your theme here. --&amp;gt; &amp;lt;/style&amp;gt;&amp;lt;/resources&amp;gt; Android 9.0 (API LEVEL 29) 이상부터 사용할 수 있다. app -&amp;gt; res -&amp;gt; values -&amp;gt; themes.xml(night) 또는 app -&amp;gt; res -&amp;gt; values-night -&amp;gt; themes.xml에서 찾을 수 있다. 핸드폰에서 설정을 해서 봐도 되지만 activity_main.xml의 디자인 모드에서 Night로 바꿔 확인해볼 수 있다. (초승달같은 모양) [참고] https://developer.android.com/codelabs/basic-android-kotlin-training-change-app-theme " }, { "title": "안드로이드 권한 요청하기", "url": "/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EA%B6%8C%ED%95%9C-%EC%9A%94%EC%B2%AD%ED%95%98%EA%B8%B0/", "categories": "Android", "tags": "Android", "date": "2022-03-13 21:01:55 +0900", "snippet": " 최종 수정일자 : 2022-03-14 23:17:18 +0900안드로이드 권한 요청하기 안드로이드의 Dangerous 권한은 API 23(마시멜로우) 이상부터는 런타임 시에 권한을 요청하도록 변경되었으며 API 22 이하는 권한에 상관없이 설치시에 자동으로 부여된다. API 23 이상부터는 사용자가 Dangerous 권한이 필요한 기능을 시작하려고 할 때에만 권한을 요청해야하며, 사용자가 필요한 권한을 거부하더라도 다른 기능들까지 사용을 못하게 해서는 안된다. 스노우 어플에서 권한 거부 시 아래와 같이 보여진다. 권한 요청 Workflow 런타임 권한을 요청할 때에는 아래와 같은 방법으로 요청 및 구현해야 한다. 매니페스트 파일에 권한을 정의한다. 사용자가 권한이 필요한 기능을 시작할 때 앱에서는 이미 권한이 수락되었는지 확인한다. 권한이 수락되지 않은 경우 왜 이 권한이 필요한지에 대해 사용자에게 설명한 후 권한 수락 창을 띄운다. 설명은 필수가 아니지만, 연구에 따르면 필요한 이유가 설명되어 있을 경우 사용자가 안심하고 수락할 가능성이 높다고 한다. 권한이 이미 수락된 경우 해당 기능이 동작할 수 있도록 한다. 권한을 거부한 경우 위 스노우 어플처럼 해당 기능만 사용을 중지하고 나머지 기능들은 그대로 둔다. 구현하기 READ_EXTERNAL_STORAGE와 WRITE_EXTERNAL_STORAGE 퍼미션을 요청하는 코드이다.1. 매니페스트 파일에 권한을 정의한다.AndroidManifest.xml &amp;lt;manifest ...&amp;gt;... &amp;lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; android:maxSdkVersion=&quot;28&quot;/&amp;gt;...&amp;lt;/manifest&amp;gt; WRITE_EXTERNAL_STORAGE의 경우 Andoid 9.0 (API LEVEL 28, 파이)까지만 해당 퍼미션을 이용해 권한 요청이 가능하다. Android 10.0부터는 Scoped Storage가 적용되어 WRITE_EXTERNAL_STORAGE의 사용이 불가능하다. 단, Android 10에서는 requestLegacyExternalStorage를 이용해 저장소에 접근할 수 있다고 한다. 그러나 11부터는 적용되지 않으므로 주의해야 한다. 2. 권한 관련 확장 함수를 작성한다.AppCompatActivityExt.kt import androidx.appcompat.app.AppCompatActivityimport androidx.core.app.ActivityCompatfun AppCompatActivity.checkSelfPermissionCompat(permission: String) = ActivityCompat.checkSelfPermission(this, permission)fun AppCompatActivity.requestPermissionsCompat(permissionsArray: Array&amp;lt;String&amp;gt;, requestCode: Int) = ActivityCompat.requestPermissions(this, permissionsArray, requestCode) 끝이 Compat으로 끝나는 경우 호환성 이슈가 있는 경우 내부적으로 알아서 처리해준다. ActivityCompat의 requestPermissions함수를 살펴보면 아래와 같다. public static void requestPermissions(final @NonNull Activity activity, final @NonNull String[] permissions, final @IntRange(from = 0) int requestCode) { [...] if (Build.VERSION.SDK_INT &amp;gt;= 23) { [...] activity.requestPermissions(permissions, requestCode); } else if (activity instanceof OnRequestPermissionsResultCallback) { [...] } API Level 23 이상에서 Dangerous 타입의 퍼미션인 경우 런타임 퍼미션으로 실행해야하고 그 이전 버전에서는 런타임 퍼미션이 적용되지 않는다. 따라서 내부적으로 위 코드처럼 23버전과 23이전 버전을 나누어 구현되어 있다. 사용하려는 함수가 XXXCompat에도 있다면 Compat에 있는 함수를 이용하는게 나을 것 같다. 3. 메인 액티비티를 구현한다.MainActivity.kt import android.Manifestimport android.content.pm.PackageManagerimport androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.widget.Buttonimport android.widget.TextViewimport android.widget.Toastimport androidx.core.app.ActivityCompatconst val READWRITE_EXTERNAL_PERMISSION = 0class MainActivity : AppCompatActivity(), ActivityCompat.OnRequestPermissionsResultCallback { private lateinit var tvReadWritePermission: TextView private lateinit var btnPermissionCheck: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) tvReadWritePermission = findViewById(R.id.textview_readwrite_permission) btnPermissionCheck = findViewById(R.id.btn_get_permission) btnPermissionCheck.setOnClickListener { checkPermissions() } } override fun onRequestPermissionsResult( requestCode: Int, permissions: Array&amp;lt;out String&amp;gt;, grantResults: IntArray ) { super.onRequestPermissionsResult(requestCode, permissions, grantResults) var grantCount = 0 if (requestCode == READWRITE_EXTERNAL_PERMISSION) { for (result in grantResults) { if (result == PackageManager.PERMISSION_GRANTED) { grantCount++ } } if (grantCount == 2) { Toast.makeText(this, &quot;읽기/쓰기 가능&quot;, Toast.LENGTH_SHORT).show() tvReadWritePermission.text = &quot;읽기/쓰기 가능&quot; } else { Toast.makeText(this, &quot;읽기/쓰기 불가&quot;, Toast.LENGTH_SHORT).show() tvReadWritePermission.text = &quot;읽기/쓰기 불가&quot; } } } private fun checkPermissions() { if (checkSelfPermissionCompat(Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED &amp;amp;&amp;amp; checkSelfPermissionCompat(Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) { tvReadWritePermission.text = &quot;읽기/쓰기 가능&quot; } else { requestPermissions() } } private fun requestPermissions() { requestPermissionsCompat( arrayOf( Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE ), READWRITE_EXTERNAL_PERMISSION ) }} 버튼을 클릭하면 checkPermissions 함수로 넘어가 위에서 작성한 확장함수인 checkSelfPermissionCompat을 이용해 읽기/쓰기에 권한이 이미 있는지 확인하고 없다면 requestPermissions 함수로 넘어가 확장함수 requestPermissionsCompat를 이용해 퍼미션을 요청한다. 퍼미션을 수락/거절하게 되면 그 결과가 onRequestPermissionsResult 함수로 콜백되어 표현된다. 테스트 API 28에서 테스트 API 31에서 테스트 [참고] https://developer.android.com/training/permissions/requesting?hl=ko " }, { "title": "안드로이드 앱 권한", "url": "/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%B1-%EA%B6%8C%ED%95%9C/", "categories": "Android", "tags": "Android", "date": "2022-03-13 20:58:19 +0900", "snippet": "안드로이드 앱 권한 앱 권한은 제한된 데이터(시스템 상태 및 연락처 정보)와 제한된 작업(페어링된 기기에 연결 및 오디오 녹음)등에 대한 접근을 보호해 개인정보를 보호한다. 앱의 메니페스트에 권한을 선언할 때 앱에 필요한 권한만 추가해야 한다. 앱 권한의 전체 목록은 아래와 같다. 전체 목록 앱 권한을 설정하지 않고도 사진 찍기, 미디어 재생 등 여러가지를 진행할 수 있음 인텐트를 이용하는 방법 (사진 찍기 : MediaStore.ACTION_IMAGE_CAPTURE) 앱 권한을 사용하는 Workflow는 아래와 같다. Workflow에서 볼 수 있는 runtime permission은 안드로이드 API 23 이상 버전에서만 적용되는 것으로, 22 이하는 runtime permission을 적용하지 않아도 된다. 그러나 maxsdk가 23 이상으로 설정되어 있는 경우 runtime permission을 적용해야 한다. 앱 권한 유형 권한 유형에는 설치 시간(install-time) 권한, 런타임 권한, 특별 권한 등 여러가지로 분류된다.설치 시간 권한 제한적으로 데이터에 접근하고 시스템이나 다른 앱에 영향을 최소한으로 미치는 권한일 경우 앱을 설치할 때 시스템에서 해당하는 권한들을 자동으로 수락한다.일반 권한 위에서 언급한 앱 권한의 전체 목록에서 Normal에 해당하는 권한들이 일반 권한으로 불린다. 개인정보 보호와 다른 앱의 작업에 거의 영향을 미치지 않는다.런타임 권한 위에서 언급한 앱 권한의 전체 목록에서 민감한 정보(사용자 GPS 위치 등)를 다루는 Dangerous에 해당하는 권한들로써 런타임(실행중일 때)에 권한을 요청해야 한다. runtime permission은 안드로이드 API 23(마시멜로우) 이상 버전에서만 적용되는 것으로, 22 이하는 runtime permission을 적용하지 않아도 설치 시간 권한에서 수락된다.앱 권한 추가 매니페스트 파일에 사용할 앱 권한을 설정한다.&amp;lt;manifest ...&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&amp;gt; &amp;lt;application ...&amp;gt; ... &amp;lt;/application&amp;gt;&amp;lt;/manifest&amp;gt; required 옵션을 통해 선택적으로 해당 권한을 사용할 수 있다. 카메라가 없는 안드로이드 기기 등 &amp;lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; required=&quot;false&quot;/&amp;gt; 하드웨어 유무는 hasSystemFeature메소드를 이용해 알아낼 수 있으며, 하드웨어가 있을때와 없을때를 다르게 처리해야 한다.// Check whether your app is running on a device that has a front-facing camera.if (applicationContext.packageManager.hasSystemFeature( PackageManager.FEATURE_CAMERA_FRONT)) { // Continue with the part of your app&#39;s workflow that requires a // front-facing camera.} else { // Gracefully degrade your app experience.} 참고 https://developer.android.com/guide/topics/permissions/overview?hl=ko " }, { "title": "옵저버 패턴 (Observer Pattern)", "url": "/posts/%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4(Observer-pattern)/", "categories": "Design Pattern", "tags": "Design Pattern", "date": "2022-03-12 14:53:45 +0900", "snippet": "옵저버 패턴 (Observer Pattern) 옵저버 패턴은 관찰자(Observer)들이 어떤 객체(Subject)를 구독함으로써 객체(Subject)에 변화가 발생했을 때 관찰자(Observer)들에게 상태 변화나 이벤트가 발생했음을 알리는 디자인 패턴이다. 관찰을 받을 대상(Subject)에는 관찰자(Observer)들이 여러개 등록될 수 있다. 옵저버는 인터페이스로 구성되며, 해당 인터페이스를 상속받아 concrete 옵저버 객체를 만들어 관찰대상을 구독하는 형태를 취한다. 장점 런타임 시에 객체를 구독하거나 취소할 수 있기 때문에 유연하다. 개방/폐쇄 원칙(OCP)을 지키므로 관찰대상의 코드 변경없이 새로운 옵저버를 등록할 수 있다. 관찰대상과 관찰자 객체들 사이의 결합도(의존성)를 낮춰준다. 인터페이스로 통신하기 때문 단점 제때 옵저버를 해제해주지 않으면 메모리 누수가 발생할 수 있다. 구독이 된 상태에서 해제하지 않고 옵저버가 종료될 경우 비동기 상태에서 옵저버들이 원하는 순서대로 상태변화를 얻어올 수 없다. 원하는 순서대로 옵저버를 등록할 수는 있지만 비동기(예를 들어 쓰레드 등)에서는 언제 등록이 되고 해제가 될지 모르기 때문 예시 이번 예시는 간단히 코틀린으로 구현했다. 아래 예시는 다음과 같은 구조로 되어있다. 메인 객체에서 관찰대상이 될 Notice 클래스와 관찰자가 될 User클래스를 인스턴스화 한다. 관찰대상에게 관찰자들을 등록한다. (registerObserver 메소드 이용) 메인 객체에서 관찰대상에게 메세지를 전달한다. 관찰대상은 메시지가 들어왔으므로 등록된 옵저버들에게 메시지를 전달한다. 옵저버 인터페이스 package observerinterface Observer { fun updateNotice(message: String)} 옵저버를 상속받는 유저 클래스 (User) package observerclass User(private val username: String) : Observer { override fun updateNotice(message: String) { println(&quot;$username : $message&quot;) }} 관찰대상 클래스 (Notice) package observerclass Notice { private val observerList = mutableListOf&amp;lt;Observer&amp;gt;() fun registerObserver(observer: Observer) { observerList.add(observer) } fun unregisterObserver(observer: Observer) { observerList.remove(observer) } fun noticeAllUser(message: String) { for (observer in observerList) { observer.updateNotice(message) } }} 메인 클래스 package observerfun main() { val notice = Notice() val user1 = User(&quot;스폰지밥&quot;) val user2 = User(&quot;뚱이&quot;) val user3 = User(&quot;징징이&quot;) val user4 = User(&quot;핑핑이&quot;) notice.registerObserver(user1) notice.registerObserver(user2) notice.registerObserver(user3) notice.registerObserver(user4) notice.noticeAllUser(&quot;게살버거 먹고싶다&quot;) notice.unregisterObserver(user3) println() notice.noticeAllUser(&quot;배부르다&quot;)} 결과 스폰지밥 : 게살버거 먹고싶다뚱이 : 게살버거 먹고싶다징징이 : 게살버거 먹고싶다핑핑이 : 게살버거 먹고싶다스폰지밥 : 배부르다뚱이 : 배부르다핑핑이 : 배부르다 참고 https://ko.wikipedia.org/wiki/옵서버_패턴 https://en.wikipedia.org/wiki/Observer_pattern " }, { "title": "MVP 패턴", "url": "/posts/MVP-%ED%8C%A8%ED%84%B4/", "categories": "Design Pattern", "tags": "Design Pattern", "date": "2022-03-11 23:59:47 +0900", "snippet": "이 글은 안드로이드를 기반으로 생각하고 내용을 정리한 글이다.MVP 패턴 MVP 패턴은 Model, View, Presenter의 앞자리를 딴 MVC 패턴에서 파생된 패턴으로, 컨트롤러 대신 프레젠터가 존재한다. MVC 패턴에서는 뷰/컨트롤러에서 모델에 접근해 데이터를 가져와 어떻게 표현할지 정했지만, MVP 패턴에서는 아래와 같이 책임을 분리해서 사용한다. Model : UI와 독립적인 데이터 구조로써 데이터, 비즈니스 로직, 규칙들을 직접적으로 다룬다. 즉, 프레젠터에서 어떤 값을 요청했을 때 그 값에 맞는 정보를 반환하거나 데이터를 저장하는 등의 역할을 한다. View : 단순히 프레젠터에서 받은 값을 표현해주고 사용자의 액션 (버튼 클릭 등)에만 관여한다. Presenter : 프레젠터는 모델과 뷰를 알고 있기 때문에 특정 메소드를 호출하여 UI에 표시하는데 필요한 작업을 진행한다. 즉, 뷰에서 전달받은 입력값이 올바르다면 모델에서 입력값에 맞는 데이터를 받아 뷰의 정보를 표현해주는 메소드에 정상값을 전달하고, 그렇지 않다면 뷰에서 에러를 처리하는 메소드에 에러값을 전달할 수 있다. MVP 패턴은 뷰에서 모델이 어떤 값을 가지고 있는지는 알 필요가 없으며, 뷰에는 여러 개의 프레젠터가 존재할 수 있고, 프레젠터에도 여러개의 뷰가 존재할 수 있다. 하나의 뷰에서 여러 모델을 사용해서 화면에 표현하고자 할 때 (뷰에 여러개의 프레젠터가 존재할 수 있다.) 다수의 뷰에서 하나의 모델을 이용해 각 화면에 표현하고자 할 때 (프레젠터에 여러개의 뷰가 존재할 수 있다.) MVP의 구조는 아래와 같다. 유저가 뷰에서 버튼 클릭 이벤트를 발생해 프레젠터에 값을 전달한다. 프레젠터는 입력값을 모델에 전달한다. (저장, 삭제, 수정 등이 될 수 있음) 모델은 입력값을 확인하고 데이터를 업데이트하거나 반환한다. 프레젠터는 모델에서 받은 값을 이용해 뷰에게 전달한다. 뷰와 프레젠터는 인터페이스로 통신하며, 프레젠터와 모델도 인터페이스로 통신을 한다.장점 뷰와 모델이 서로 의존성이 없기 때문에 뷰가 변경되더라도 같은 값을 사용한다면 모델을 변경하지 않아도 된다. 모델에 기능이 추가되더라도 뷰에서 그 기능에 해당하는 UI만 만들어 표현해주면 된다. 서로 분리되어 있기 때문에 단위 테스트(Unit Test)가 쉬워진다. JUnit, Mockito 등을 이용 단점 프레젠터는 뷰로부터 데이터를 받아 모델의 값을 업데이트하거나 표현해주기 위한 코드로 구현되는데, 뷰에서 표현하고자 하는 값이 많아질수록 프레젠터는 커질 수밖에 없다.예시 클래스명이나 파일명은 임의로 작성했다. 실제 앱에서는 더 명확한 의미의 이름들이 필요할 것 같다. 액티비티와 프레젠터에 인터페이스를 상속받고 서로 통신할 수 있도록 구현했다. 프레젠터에는 뷰와 모델을 생성자로 받는다.메인 레이아웃 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_margin=&quot;10dp&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;EditText android:id=&quot;@+id/edit_username&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginEnd=&quot;4dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/btn_search&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&amp;gt; &amp;lt;Button android:id=&quot;@+id/btn_search&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;검색&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/text_username_string&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;이름 : &quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.415&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/edit_username&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/text_username&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#A2A2A2&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.104&quot; app:layout_constraintStart_toEndOf=&quot;@+id/text_username_string&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/edit_username&quot; tools:text=&quot;AAAA&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/text_age_string&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;나이 : &quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.415&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/text_username_string&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/text_age&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#A2A2A2&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.104&quot; app:layout_constraintStart_toEndOf=&quot;@+id/text_age_string&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/text_username_string&quot; tools:text=&quot;AAAA&quot; /&amp;gt;&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt; 메인 인터페이스 package com.example.mvpinterface MainContract { interface View { fun showUser(userInfo: UserInfo) fun error(msg: String) } interface Presenter { fun addUser(userInfo: UserInfo) fun findUser(username: String) }} 프레젠터와 모델 사이의 인터페이스 package com.example.mvpinterface UserRepository { fun addUser(userInfo: UserInfo) fun findUser(username: String): UserInfo?} 유저 정보와 관련된 데이터 클래스 package com.example.mvpdata class UserInfo( val username: String, val age: Int) 유저 리스트 모델 package com.example.mvpclass UserListModel : UserRepository { private val userList = mutableListOf&amp;lt;UserInfo&amp;gt;() override fun addUser(userInfo: UserInfo) { userList.add(userInfo) } override fun findUser(username: String): UserInfo? { return userList.find { it.username == username } }} 프레젠터 package com.example.mvpclass MainPresenter( private val model: UserRepository, private val view: MainContract.View) : MainContract.Presenter { override fun addUser(userInfo: UserInfo) { model.addUser(userInfo) } override fun findUser(username: String) { val userInfo = model.findUser(username) if (userInfo == null) { view.error(&quot;유저를 찾을 수 없습니다.&quot;) } else { view.showUser(userInfo) } }} 메인 액티비티 package com.example.mvpimport androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.widget.Buttonimport android.widget.EditTextimport android.widget.TextViewimport android.widget.Toastclass MainActivity : AppCompatActivity(), MainContract.View { private lateinit var editUserName: EditText private lateinit var btnSearch: Button private lateinit var textUsername: TextView private lateinit var textAge: TextView private lateinit var presenter: MainContract.Presenter override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) presenter = MainPresenter(UserListModel(), this) presenter.addUser(UserInfo(&quot;AAAA&quot;, 10)) presenter.addUser(UserInfo(&quot;BBBB&quot;, 20)) presenter.addUser(UserInfo(&quot;CCCC&quot;, 30)) presenter.addUser(UserInfo(&quot;DDDD&quot;, 40)) editUserName = findViewById(R.id.edit_username) btnSearch = findViewById(R.id.btn_search) textUsername = findViewById(R.id.text_username) textAge = findViewById(R.id.text_age) btnSearch.setOnClickListener { presenter.findUser(editUserName.text.toString()) } } override fun showUser(userInfo: UserInfo) { textUsername.text = userInfo.username textAge.text = userInfo.age.toString() } override fun error(msg: String) { Toast.makeText(this, msg, Toast.LENGTH_SHORT).show() textUsername.text = &quot;알 수 없음&quot; textAge.text = &quot;알 수 없음&quot; }} 위 코드는 아래와 같은 구조로 작성되어 있다. 메인 액티비티(뷰)에서는 프레젠터로 값을 요청하고 프레젠터는 값을 받아 모델에 전달한다. 모델에서는 해당 값을 토대로 정보를 프레젠터로 반환하거나 추가한다. 프레젠터는 모델에서 받은 값을 이용해 뷰의 인터페이스를 통해 전달한다. 뷰는 프레젠터에서 받은 값을 이용해 화면에 표현한다. 참고 https://en.wikipedia.org/wiki/Model-view-presenter https://ko.wikipedia.org/wiki/모델-뷰-프리젠터 https://www.baeldung.com/mvc-vs-mvp-pattern " }, { "title": "MVC 패턴", "url": "/posts/MVC-%ED%8C%A8%ED%84%B4/", "categories": "Design Pattern", "tags": "Design Pattern", "date": "2022-03-11 15:18:16 +0900", "snippet": "MVC 패턴이 글은 안드로이드를 기반으로 생각하고 내용을 정리한 글이다. MVC와 MVP 패턴을 이해하려면 먼저 왜 이러한 아키텍처 패턴을 써야하는지 알아야 한다.아키텍처 패턴 위키에 따르면 아키텍처 패턴을 아래와 같이 정의하고 있다. 아키텍처 패턴(architectural pattern)은 주어진 문맥 안에서 소프트웨어 아키텍처의 공통적인 발생 문제에 대한 일반적인, 재사용 가능한 해결책을 의미한다. 건물을 지을 때 어떤 방식으로 지을 것인지 고민하는 것처럼 소프트웨어를 개발할 때에도 어떤 방식으로 개발을 진행해야 고민해야 하는데, 이러한 고민을 해결하기 위해 아키텍처 패턴이라는 것이 등장했다. 한 건물에 여러가지의 방식을 선택하면 관리하기 힘든것처럼 소프트웨어에서도 마찬가지이므로 되도록 한가지 방식을 이용해 개발하는것이 유리하다. 이렇게되면 다른 소프트웨어를 개발할 때에도 비슷한 경우일 때 동일한 방식을 사용할 수 있으므로 재사용성이 높아지게 되며, 개발 도중에 새로운 관리자나 개발자가 참여하더라도 어떤 패턴으로 개발이 되었는지를 알 수 있다면 개발하는데 필요한 비용(시간, 노력 등)이 줄어들 수 있는 이점이 있기 때문에 명확히 정의된 아키텍처가 중요하다.MVC 패턴 MVC 패턴은 Model, View, Controller의 앞자리를 따온 것으로 MVP, MVVM 등의 아키텍처 패턴에 기초가 되었다. MVC 패턴은 아래와 같은 책임으로 분리한다. Model : UI와 독립적인 데이터 구조로써 데이터, 비즈니스 로직, 규칙들을 직접적으로 다룬다. View : 텍스트, 체크박스 등의 사용자 UI를 나타낸다. Controller : 데이터와 비즈니스 로직 사이의 상호동작을 관리한다. 즉, 사용자의 입력을 받고 처리하는 것을 담당한다. 위 사진을 보면 MVC 패턴에는 여러가지 구현 방법이 존재한다는 것을 알 수 있으며, 첫 번째 사진은 MVC의 기본 모습이고 두 번째는 웹에서 사용하는 MVC 패턴(Spring Framework)이다. 뭔가 웹에서 사용하는 MVC 패턴은 MVP와 비슷해 보이는 느낌이 강한 것 같다. 안드로이드에서는 View와 Controller가 같이 존재한다고 볼 수 있기 때문에 View/Controller -&amp;gt; Model을 참조하게 된다. 안드로이드가 아닌 자바 기반의 MVC 패턴은 아래와 같다고 한다. MVC 패턴 (tutorialspoint) 위 글을 보니까 더 헷갈리는 거 같기도하고… 장점 가장 단순한 구조여서 규모가 크지 않은 프로젝트를 진행할 때 사용될 수 있으며 개발 시간이 짧다. 모델에는 비즈니스 로직을 구현하고 뷰에서는 모델에서 가져다 표현해주기만 하면 되기 때문 단점 View/Controller와 Model이 밀접하게 연결되어 있어서 View/Controller의 단위 테스트(Unit Test)가 힘들다는 단점이 있다. 의존성이 높기 때문에 어플리케이션이 커질수록 복잡하고 유지보수가 어려워질 수 있다.예시레이아웃 코드 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_margin=&quot;10dp&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;EditText android:id=&quot;@+id/edit_username&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginEnd=&quot;4dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/btn_search&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&amp;gt; &amp;lt;Button android:id=&quot;@+id/btn_search&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;검색&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/text_username_string&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;이름 : &quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.415&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/edit_username&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/text_username&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#A2A2A2&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.104&quot; app:layout_constraintStart_toEndOf=&quot;@+id/text_username_string&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/edit_username&quot; tools:text=&quot;AAAA&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/text_age_string&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;나이 : &quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.415&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/text_username_string&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/text_age&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#A2A2A2&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.104&quot; app:layout_constraintStart_toEndOf=&quot;@+id/text_age_string&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/text_username_string&quot; tools:text=&quot;AAAA&quot; /&amp;gt;&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt; 유저 정보 데이터 클래스 package com.example.mvcdata class UserInfo( val username: String, val age: Int) 모델 package com.example.mvcclass UserListModel { private val userList = mutableListOf&amp;lt;UserInfo&amp;gt;() fun addUser(userInfo: UserInfo) { userList.add(userInfo) } fun findUser(username: String): UserInfo? { return userList.find { it.username == username } }} 메인 액티비티 package com.example.mvcimport androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.widget.Buttonimport android.widget.EditTextimport android.widget.TextViewclass MainActivity : AppCompatActivity() { private lateinit var editUserName: EditText private lateinit var btnSearch: Button private lateinit var textUsername: TextView private lateinit var textAge: TextView private val userListModel = UserListModel() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) userListModel.addUser(UserInfo(&quot;AAAA&quot;, 10)) userListModel.addUser(UserInfo(&quot;BBBB&quot;, 20)) userListModel.addUser(UserInfo(&quot;CCCC&quot;, 30)) userListModel.addUser(UserInfo(&quot;DDDD&quot;, 40)) editUserName = findViewById(R.id.edit_username) btnSearch = findViewById(R.id.btn_search) textUsername = findViewById(R.id.text_username) textAge = findViewById(R.id.text_age) btnSearch.setOnClickListener { val user = userListModel.findUser(editUserName.text.toString()) if (user == null) { textUsername.text = &quot;알 수 없음&quot; textAge.text = &quot;알 수 없음&quot; } else { textUsername.text = user.username textAge.text = user.age.toString() } } }} 메인 액티비티의 버튼을 살펴보면 모델인 UserListModel을 직접 호출하고 값을 가져오는 것을 확인할 수 있다.완성화면 참고 https://www.redhat.com/architect/5-essential-patterns-software-architecture https://developer.mozilla.org/ko/docs/Glossary/MVC https://en.wikipedia.org/wiki/Model-view-controller https://ko.wikipedia.org/wiki/모델-뷰-컨트롤러 https://www.baeldung.com/mvc-vs-mvp-pattern https://www.tutorialspoint.com/design_pattern/mvc_pattern.htm " }, { "title": "디자인 패턴", "url": "/posts/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/", "categories": "Design Pattern", "tags": "Design Pattern", "date": "2022-03-05 02:03:05 +0900", "snippet": "작성중…마지막 업데이트 : 2022-03-19 18:48:01 +0900주요 디자인 패턴디자인 패턴이란 객체 지향 설계는 변화에 유연하게 대응하기 위해 특정 상황에 맞는 패턴을 이용하게 되는데 이를 디자인 패턴이라고 한다. 여기서 특정 상황이란 클래스, 객체의 구성, 객체 간 메시지 흐름에서 알맞는 설계를 하는 것이다. 디자인 패턴을 배우면서 느낄 수 있는 장점은 아래와 같다. 상황에 맞는 설계를 빠르게 적용시킬 수 있다. 각 패턴의 장단점을 통해 어떻게 설계할 것인지에 대해 도움을 받을 수 있다. 설계한 패턴에 이름을 붙임으로써 문서화, 이해, 유지보수에 도움을 얻을 수 있다. 전략 패턴 (Strategy Pattern) 전략 패턴은 전략(Strategy)과 컨텍스트(Context)라는 이름으로 나뉘어지는데, 여기서 전략이란 어떤 기능을 수행하는데 필요한 알고리즘을 직접 구현한 객체가 되며 콘텍스트는 이를 사용하는 책임을 갖고 있는 것을 말한다. 따라서 특정 컨텍스트에서 어떤 기능을 수행하는데 필요한 알고리즘을 따로 분리해내 컨텍스트에서는 어떤 알고리즘을 사용하는지 알 필요가 없다. 전략 패턴을 사용했을때와 사용하지 않았을 때의 코드를 비교해자면 아래와 같다. 사용하지 않았을 때 data class Item(val price: Int) class Coupon { fun calculatePrice(item: Item, isFirst: Boolean): Int { if (isFirst) { return item.price - (item.price * 0.8).toInt() } else { return item.price - (item.price * 0.5).toInt() } } } 첫 번째 주문일 경우 80퍼센트의 할인을 해주고 그렇지 않다면 50퍼센트를 할인해주는 코드이다. 만약 첫 번째 주문이 아닌 오랜만에 주문했을 경우의 코드를 추가한다고 했을 때, if ~ else 구문과 메소드의 매개변수들은 점점 늘어나게 되고 관리가 힘들어지게 된다. 사용했을 때 interface DiscountStrategy { val ratio: Double fun getDiscountPrice(price: Int): Int } class FirstOrderDiscount : DiscountStrategy { override val ratio: Double = 0.8 override fun getDiscountPrice(price: Int): Int { return price - (price * ratio).toInt() } } class OrderDiscount : DiscountStrategy { override val ratio: Double = 0.5 override fun getDiscountPrice(price: Int): Int { return price - (price * ratio).toInt() } } data class Item(val price: Int) class Coupon(private val discountStrategy: DiscountStrategy) { fun calculatePrice(item: Item): Int { return discountStrategy.getDiscountPrice(item.price) } } 사용하지 않았을 때와 동일한 값을 반환하지만 새로운 할인 전략이 발생했을 때 DiscountStrategy를 상속받는 클래스를 이용해 정의하고 사용할 수 있게 된다. 이렇게 되면 객체 지향 설계 중 하나인 OCP원칙을 지킬 수 있게 된다. 템플릿 메서드 패턴 (Template Method) 프로그램을 구현하다 보면, 완전히 동일한 절차를 가진 코드를 작성하게 될 수 있다. 즉, 일부 과정의 구현만 다를 뿐 나머지 구현은 완전히 같을 수 있는데, 그 예는 아래와 같다. class DbAuthenticator { fun authenticate(id: String, pw: String): Auth { val user = userDao.selectById(id) auth = user.equalPassword(pw) if (!auth) { throw Exception() } return new Auth(id, user.getName()); } } class LdapAuthenticator { fun authenticate(id: String, pw: String): Auth { auth = ldapClient.authenticate(id, pw) if (!aut) { throw Exception() } ctx = ldapClient.find(id) return new Auth(id, ctx.getAttribute(&quot;name)) } } 위 코드는 단순히 DB와 LDAP를 이용해 인증하는 구조인데, 몇 부분을 제외하고는 완전히 동일한 형태를 띄게 된다. 지금은 DB, LDAP만 있지만 또다른 인증 방법이 나오게 된다면 코드의 중복이 많이 발생하게 됨으로써 유지보수가 어려워지게 된다. 코드의 중복이 많아지면 로직 중 하나를 수정할 때 모든 관련된 코드를 수정해야하는 단점이 존재한다. 템플릿 패턴은 이러한 코드의 중복을 줄여주도록 아래와 같이 구성된다. 실행 과정을 구현한 상위 클래스 실행 과정의 일부 단계를 구현한 하위 클래스 상위 클래스는 추상 메서드를 이용해 호출하며 하위 클래스에서는 이러한 추상 메서드를 직접 구현함으로써 코드의 중복을 줄일 수 있다. 그 예는 아래와 같다. abstract class Authenticator { fun authenticate(id: String, pw: String) { if (!doAuthenticate(id, pw)) { throw Exception() } return createAuth(id) } protected abstract fun doAuthenticate(id: String, pw: String): Boolean protected abstract fun createAuth(id: String): Auth } class DbAuthenticator : Authenticator() { override fun doAuthenticate(id: String, pw: String): Boolean { ... return true } override fun createAuth(id: String): Auth { ... return Auth(id) } } 위와 같이 구현하게 되면 Authenticator를 상속받는 클래스에서는 단순히 상위 클래스의 추상 메서드들을 재정의해면 된다. 일반적으로 상속은 하위 클래스가 상위 클래스의 기능을 재사용할지 여부를 확인하지만 템플릿 메서드 패턴에서는 상위 클래스가 흐름을 제어하고 그 흐름에 하위 클래스가 끼어들어가게 되는 것이다. 또한, 템플릿 메서드 패턴에 훅(Hook) 메서드라는 것을 이용해 하위 클래스에서 확장할 수도 있는데 그 구조는 아래와 같다. abstract class Authenticator { fun authenticate(id: String, pw: String) { if (!doAuthenticate(id, pw)) { throw Exception() } doSomthing() return createAuth(id) } protected abstract fun doAuthenticate(id: String, pw: String): Boolean protected abstract fun createAuth(id: String): Auth protected fun doSomthing() { ... } } 위 코드에서 doSomething메서드를 protected로 선언함으로써 인증이 끝나고 어떤 작업을 해야할 때 그 작업을 하위 클래스에서 확장하도록 할 수 있다. 상태 패턴 (State) 상태(State)에 따라 동일한 기능이 다르게 구현되어야 할 때 사용할 수 있다. 상태 패턴을 이용하지 않는다면 하나의 메서드에 상태에 따른 기능들을 if문으로 다 분기시켜줘야하기 때문에 코드가 길어짐으로써 유지보수가 어려워지게 된다. 상태를 인터페이스를 이용해 별도 타입으로 분리해서 각 상태 별로 알맞은 하위 타입(콘크리트 클래스)을 구현하게 된다. class VendingMachine { private var state = NoCoinState() fun insertCoin(coin: Int) { state.increaseCoin(coin, this) } fun select(prodId: Int) { ... } fun changeState(state: State) { ... } } interface State { fun increaseCoin(coin: Int, vm: VendingMachine) fun select(prodId: Int, vm: VendingMachine) } class NoCoinState : State { override fun increaseCoin(coin: Int, vm: VendingMachine) {} override fun select(prodId: Int, vm: VendingMachine) {} } class SelectableState : State { override fun increaseCoin(coin: Int, vm: VendingMachine) {} override fun select(prodId: Int, vm: VendingMachine) {} } 코인이 없을 때 select 호출 시 비프음을 내도록 할 수도 있고 선택 가능한 상태일 때 select 호출 시 제품을 제공하도록 구현할 수 있다. 상태 패턴의 장점은 새로운 상태가 추가되더라도 콘텍스트(VendingMachine)가 받는 영향은 최소화 됨으로써 상태가 많아지더라도 클래스의 개수만 증가할 뿐 코드의 복잡도는 증가하지 않아 유지 보수에 유리하다. 또한, 각 상태 별로 코드가 구현되어 있기 때문에 상태에 따른 동작들을 수정하기가 쉽다. 상태 변화는 누가 해야하는가? 상태 변화는 콘텍스트(VendingMachine)나 상태(NoCoinState, SelectableState 등) 둘 중 하나가 된다. 콘텍스트에서 변경할 경우 아래와 같이 구현될 수 있다. class VendingMachine { private var state = NoCoinState() fun insertCoin(coin: Int) { ... } fun select(prodId: Int) { ... if (특정조건) { changeState(NoCoinState()) } } fun changeState(state: State) { state = State } } 콘텍스트에서 변경할 경우 비교적 상태 개수가 적고 상태 변경의 규칙이 거의 바뀌지 않는 경우에 유리한데, 상태 종류나 규칙이 자주 변경될 경우 상태 변경 처리에 대한 코드가 복잡해질 수 있다. 상태에서 변경할 경우 아래와 같이 구현될 수 있다. class NoCoinState : State { override fun increaseCoin(coin: Int, vm: VendingMachine) {} override fun select(prodId: Int, vm: VendingMachine) { vm.increaseCoin(coin) vm.changeState(SelectableState()) } } 상태에서 변경할 경우 콘텍스트(VendingMachine)에 영향을 주지 않으면서 상태나 규칙을 변경할 수 있게 된다. 그러나 상태 변경 규칙이 여러 클래스(SelectableState 등)에 분산되어 있어 구현 클래스가 많아질수록 변경 규칙을 파악하기 어려워질 수 있다. 이처럼 상태 변화를 누가 하는가에 따라 장단점이 있기 때문에 주어진 상황에 알맞는 방식을 선택해야 한다.파사드(Facade) 패턴 파사드 패턴은 코드 중복과 직접적인 의존을 해결하는데 도움을 주는 패턴이다. 예를 들어서 아래와 같은 코드가 있다고 가정해볼 때 Notebook과 Desktop은 Power, Memory, Cpu에 의존하고 있다. 패턴 적용 전 class ModelAPower { fun turnOn() { }} class Memory { fun load() { }} class Cpu { fun execute() { }} class Notebook { private val modelAPower = ModelAPower() private val memory = Memory() private val cpu = Cpu() fun start() { modelAPower.turnOn() memory.load() cpu.execute() }} class Desktop { private val modelAPower = ModelAPower() private val memory = Memory() private val cpu = Cpu() fun start() { modelAPower.turnOn() memory.load() cpu.execute() }} 위 코드는 몇가지 문제가 있는데 하나씩 살펴보면 아래와 같다. 동일한 코드가 중복된다. (turnOn, load, execute, 변수 선언) 실행의 순서가 power, memory, cpu에서 power ,cpu, memory로 바뀐다면 Notebook과 Desktop의 코드가 변경되어야 한다. power가 ModelA에서 modelB로 바뀔 경우에도 Notebook과 Desktop의 코드가 변경되어야 한다. 위 문제는 Notebook과 Desktop이 power, memory, cpu를 의존하고 있기 때문에 발생하는 문제인데, 파사드 패턴은 코드의 중복과 의존성을 줄여주기 위한 디자인 패턴이다. 아래는 파사드 패턴을 적용했을 때의 결과이다. 패턴 적용 후 package facade_pattern class ModelAPower { fun turnOn() { }} class Memory { fun load() { }} class Cpu { fun execute() { }} class Computer { private val modelAPower = ModelAPower() private val memory = Memory() private val cpu = Cpu() fun start() { modelAPower.turnOn() memory.load() cpu.execute() }} class Notebook { private val computer = Computer() fun start() { computer.start() }} class Desktop { private val computer = Computer() fun start() { computer.start() }} 파사드 패턴을 적용함으로써 클라이언트 (Notebook, Desktop)와 서브 시스템 (Power, Cpu, Memory)간의 직접적인 의존을 제거했으며 코드의 중복 또한 줄어들게 되었다. 장점과 특징 파사드를 정의함으로써 클라이언트 변경 없이 서브 시스템을 변경할 수 있다는 장점이 있다. 단지 여러 클라이언트의 중복된 코드들을 파사드로 추상화하여 사용했을 뿐, 서브 시스템에 대한 직접적인 접근을 막는 것은 아니다. 필요한 경우 클라이언트에서 서브 시스템을 바로 사용할 수 있다. 퍼사드는 공통적인 작업에 대해 간편한 메소드들을 제공해준다. 좋게 작성되지 않은 API의 집합을 하나의 좋게 작성된 API로 감싸준다. 시스템의 복잡성을 숨기고 클라이언트에 더 간단한 인터페이스를 제공한다. 예를 들어서 적용 전 코드에서 Notebook과 Desktop의 start 메소드가 훨씬 더 복잡한 로직을 가지고 있을 경우 구현 도중에 코드를 누락하거나 잘못 작성할 수 있는 가능성이 높다. 따라서 파사드 패턴을 적용함으로써 클라이언트는 어떻게 구현해야 되는지에 대한것은 알 필요가 없으므로 더 간단하게 코드를 사용할 수 있게 된다. 인터페이스와 같이 사용하여 서브 시스템의 교체를 쉽게 할 수도 있다.인터페이스와 비교 인터페이스는 공통된 메소드들을 정의해 내부 코드를 감춤으로써 확장과 변경에 초점이 맞춰져있지만 파사드 패턴은 내부 코드를 감추는 것은 동일하지만 단순히 공통적으로 사용되는 클래스와 메소드들을 하나의 파사드 클래스 내부 메소드 안에서 묶어주는 역할을 한다. 파사드 패턴은 사용하는 클래스와 의존 관계에 있다.어댑터 패턴과 비교 어댑터 패턴은 단순히 호환되지 않는 두 개의 인터페이스를 연결해주는 패턴이다. 즉, DVI to HDMI 케이블같은 것을 의미한다. 그러나 파사드 패턴은 기가지니처럼 어떤 행동 하나에 티비, 전등, 가스 등을 제어하는 것과 동일하게 이해할 수 있다. 참고추상 팩토리 패턴 어떤 조건별로 다른 객체들을 생성해야할 때 추상 팩토리 패턴을 사용할 수 있다. 객체의 생성 책임을 분리한다.그릴 객체 추상/콘크리트 클래스 abstract class DrawObject { abstract var point: Point abstract var size: Size abstract fun draw()}class Image(override var point: Point, override var size: Size) : DrawObject() { override fun draw() { println(&quot;Image -&amp;gt; point: ${point}, size: $size&quot;) }}class Rectangle(override var point: Point, override var size: Size) : DrawObject() { override fun draw() { println(&quot;Rectangle -&amp;gt; point: ${point}, size: $size&quot;) }} 그릴 객체 팩토리 클래스 구현 abstract class DrawObjectFactory { companion object { fun getFactory(index: Int): DrawObjectFactory { return when (index) { 1 -&amp;gt; RectangleFactory() else -&amp;gt; ImageFactory() } } } abstract fun createDrawObject(point: Point, size: Size): DrawObject} 사각형, 이미지 팩토리 클래스 구현 class ImageFactory : DrawObjectFactory() { override fun createDrawObject(point: Point, size: Size): DrawObject { return Image(Point(11, 22), Size(33, 44)) }}class RectangleFactory : DrawObjectFactory() { override fun createDrawObject(point: Point, size: Size): DrawObject { return Rectangle(Point(10, 20), Size(30, 40)) }} 메인 구현 fun main() { // 사각형 var drawObjectFactory = DrawObjectFactory.getFactory(1) var drawObject = drawObjectFactory.createDrawObject(Point(10, 20), Size(30, 40)) drawObject.draw() // 이미지 drawObjectFactory = DrawObjectFactory.getFactory(2) drawObject = drawObjectFactory.createDrawObject(Point(11, 22), Size(33, 44)) drawObject.draw()} 결과 Rectangle -&amp;gt; point: Point(x=10, y=20), size: Size(width=30, height=40)Image -&amp;gt; point: Point(x=11, y=22), size: Size(width=33, height=44) 장점 클라이언트 변경 없이 사용할 객체를 동적으로 교체할 수 있다. 객체의 생성을 분리함으로써 메인에서는 생성에 대한 책임없이 사용하기만 하면 된다.컴포지트 패턴 클라이언트가 복합 객체(group)나 단일 객체를 동일하게 취급하는 것으로 전체-부분을 구성하는 클래스가 동일 인터페이스를 구현하도록 하는 디자인 패턴이다. 두꺼비집으로 생각하면 쉬울 것 같다.interface Device { fun turnOn() fun turnOff()}class Computer : Device { override fun turnOn() { } override fun turnOff() { }}class Light : Device { override fun turnOn() { } override fun turnOff() { }}class InternetCafe : Device { private val deviceList = mutableListOf&amp;lt;Device&amp;gt;() override fun turnOn() { deviceList.forEach { it.turnOn() } } override fun turnOff() { deviceList.forEach { it.turnOff() } } fun addDevice(device: Device) { deviceList.add(device) }}fun main() { val internetCafe = InternetCafe() internetCafe.addDevice(Computer()) internetCafe.addDevice(Computer()) internetCafe.addDevice(Light()) internetCafe.addDevice(Light()) internetCafe.turnOff()}장점 클라이언트가 컴포지트(그룹)과 컴포넌트(단일 객체)를 구분하지 않고 컴포넌트 인터페이스만으로 프로그래밍 할 수 있다." }, { "title": "안드로이드 UI 레이어", "url": "/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-UI-%EB%A0%88%EC%9D%B4%EC%96%B4/", "categories": "Android", "tags": "Android", "date": "2022-02-28 21:13:12 +0900", "snippet": "안드로이드 UI 레이어 UI란 무엇인가를 생각해봤을 때 화면에 데이터를 시각적으로 표시하고 사용자와 상호작용하는 역할을 수행하는 것을 의미한다. 사용자 상호작용이란 버튼을 클릭하거나 스크롤을 내리는 등의 행위를 의미한다. 이 UI 레이어에는 데이터를 표시할 수 있는 형태로 변환되어 전달되어야 한다. 즉, UI에서 raw 데이터를 가공해서 표현하는 행위를 해서는 안된다. UI는 다음과 같이 구성될 수 있다. 데이터를 어떻게 보여줄것인가? 위 그림에서 볼 수 있듯이 앱에서 사용자에게 표시하는 부분을 UI Elements라고 하고 그 UI Elements가 가지고 있는 상태들을 UI State라고 한다. UI State에는 해당 UI를 보는데 필요한 정보들 (로그인 유무, 접근가능한지 등)을 담고 있다.data class NewsUiState(val isSignedIn: Boolean = false,val isPremium: Boolean = false,val newsItems: List&amp;lt;NewsItemUiState&amp;gt; = listOf(),val userMessages: List&amp;lt;Message&amp;gt; = listOf())data class NewsItemUiState( val title: String, val body: String, val bookmarked: Boolean = false, ...) 위와 같은 코드가 있을 때 NewsUiState클래스는 뉴스의 메인 화면을 의미하며 로그인, 프리미엄 등에 따라 보이는게 달라져야 하며 NewsItemUiState는 제목, 내용, 북마크 유무 등이 들어갈 수 있다. UI 자체에서 상태를 변경할 수 없도록 val타입으로 선언해주었는데, 그 이유는 만약 실수든 고의든 상태가 변경되면 동일한 정보가 다른 곳에서 사용되어 데이터 불일치와 같은 버그가 발생할 수 있기 때문이다.이후 부분은 이해가 잘 안돼서 나중에 정리할 예정이다..https://developer.android.com/jetpack/guide/ui-layer" }, { "title": "안드로이드 앱 아키텍처", "url": "/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%B1-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/", "categories": "Android", "tags": "Android", "date": "2022-02-27 17:54:00 +0900", "snippet": "안드로이드 앱 아키텍처 안드로이드 운영체제는 새로운 앱이 실행됐을 때 공간을 확보하기 위해 언제든지 현재 실행중인 앱을 종료시킬 수 있으며 각각의 구성요소들은 개별적으로 실행이 가능하기 때문에 데이터나 상태를 앱 구성요소에 저장해서는 안되며, 앱 구성요소들이 서로 종속되면 안된다.그렇다면 어떻게 설계를 해야 위와 같은 문제를 해결할 수 있을까? 몇 가지 원칙을 적용해 앱 아키텍처를 설계해야 한다. 그 원칙을 하나씩 살펴보자.1. 관심사를 분리해야 한다. 관심사를 분리한다는 것은 클래스에 대한 의존성을 최소화한다는 것이다. 의존성을 최소화하지 않는다면 어떻게 될까? Activity와 Fragment에 모든 코드를 작성하는 경우가 있을 수 있는데 이렇게 되면 테스트를 하기 어려운 뿐더러 많은 코드들이 Activity와 Fragment에 의존하기 때문에 코드의 재사용 관점에서도 올바르지 않다. 어떻게 분리를 해야하는가? 위 경우에서는 UI 기반 클래스는 UI 및 운영체제와 상호작용을 처리하는 코드만 작성해야 한다. 이렇게 클래스를 최대한 가볍게 유지할수록 구성요소의 Lifecycle과 관련된 많은 문제들을 피할 수 있게 됨으로서 테스트도 쉽게 할 수 있다. 2. 데이터 모델에서 UI를 도출해야 한다. 데이터 모델은 일반적으로 앱의 데이터를 나타낸다. 데이터 모델은 UI 및 기타 구성요소와 독립되어 있으므로 UI가 변경되더라도 데이터는 UI에 의존하지 않기 때문에 쉽게 변경이 가능하다. 이러한 데이터 모델은 대부분 데이터베이스와 같은 지속가능한 데이터 모델을 의미한다. 지속가능한 모델의 장점은 아래와 같다. 안드로이드 운영체제에서 메모리 확보를 위해 앱을 종료시키더라도 데이터는 남아있다. 네트워크에 연결되지 않았거나 속도가 느리더라도 로컬에 남아있는 데이터를 이용해 작동이 가능하다. 아마 Model Driven Development를 의미하는 것 같다. 이 부분은 확인이 필요하다. 그렇다면 어떠한 방식으로 앱 아키텍처를 구현해야 할까? 위에서 언급한 일반적인 아키텍처 원칙을 고려하면 각 앱에는 두 개 이상의 레이어가 있어야 한다. 화면에 데이터를 표시하는 UI 레이어 앱의 비즈니스 로직을 포함하고 데이터를 노출하는 데이터 레이어 UI와 데이터 레이어 간의 상호작용을 최소화하고 재사용하기 위한 도메인 레이어 (옵션) 3가지의 레이어를 하나씩 살펴보자. 각 레이어에 대한 대략적인 내용으로, 자세한 내용은 추후 작성할 예정이다.1. UI 레이어 프레젠테이션 레이어라고도 부르며 화면에 데이터를 표시하는 역할을 담당한다. 사용자와의 상호작용 (버튼 클릭)이나 외부 입력(네트워크)로 인해 데이터가 변할 때마다 변경사항을 반영할 수 있도록 UI가 업데이트 되어야 한다. 이 UI 레이어는 2가지로 구성된다. 화면에 데이터를 렌더링하는 UI 요소 (뷰 또는 Jetpack Compose 이용) 데이터를 보유하고 이를 UI에 노출하여 로직을 처리하는 상태 홀더 (ViewModel 클래스) 2. 데이터 레이어 데이터 레이어에는 비즈니스 로직이 포함되어 있다. 비즈니스 로직이란 앱의 데이터를 생성, 저장, 변경하는 로직을 의미한다. 앱에서 처리하는 다양한 유형의 데이터마다 저장소 클래스를 구현해야 한다. 영화 관련 데이터는 MoviesRepository클래스, 결제는 PlaymentsRepository와 같은 방식으로 데이터마다 저장소 클래스를 구현한다. 이 클래스들은 하나의 데이터 소스만 이용해야 한다. 파일이면 파일, DB면 DB, … 3. 도메인 레이어 도메인 레이어는 UI 레이어와 데이터 레이어 사이에 있는 레이어로서 옵션이다. 복잡한 비즈니스 로직, 또는 여러 ViewModel에서 재사용되는 간단한 비즈니스 로직의 캡슐화를 담당한다. 따라서 복잡성을 처리하거나 재사용을 해야할 때 사용한다. 이런 구성요소들 간의 종속은 어떻게 처리해야 할까? 개발을 하다보면 다른 클래스를 종속할 수 밖에 없는데, 이럴때 사용하거나 구현하기 쉽게 해주는 디자인 패턴이 존재한다. Dependency Injection(DI) DI를 사용하면 클래스가 자신의 종속 객체를 구성할 필요가 없다. 런타임 시 다른 클래스가 종속 객체를 제공하는 방식으로 구현된다. 생성자 또는 프로퍼티를 이용 Service Locator 클래스가 자신의 종속 객체를 구성하는 대신 종속 객체를 가져올 수 있는 레지스트리를 제공한다. 하나의 클래스에서 종속 객체들을 선언해준 후 끌어다 쓰는 형식을 의미한다. 위 패턴을 적용하면 코드의 중복과 복잡성을 줄일 수 있으며, 종속 객체를 관리하기 편하므로 코드를 확장할 수 있다. 안드로이드에서 DI를 적용시켜주는 라이브러리들이 있다. Koin, Dagger, Hilt, … [최종 업데이트]2022-02-27 17:54:00 +0900https://developer.android.com/jetpack/guide" }, { "title": "안드로이드 앱 구조", "url": "/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%B1-%EA%B5%AC%EC%A1%B0/", "categories": "Android", "tags": "Android", "date": "2022-02-26 16:35:03 +0900", "snippet": "안드로이드 앱 구조의미와 기능에 대해서만 대략적으로 알아보자. 안드로이드에는 두 가지 설치파일이 존재한다. apk : Android Package로 앱을 설치하고 실행하는데 필요한 데이터들이 포함되어 있다. aab : Android App Bundle로 런타임에 필요하지 않은 추가 메타데이터를 포함해 앱 프로젝트의 콘텐츠가 포함되어 있다. aab는 설치파일이 아닌 모음집같은 형태로, 구글 플레이스토어에 등록되면 구글 플레이스토어 서버에서 특정 디바이스에 최적화된 리소스 및 파일로 변환해 apk형식으로 변환해준다. 안드로이드 앱은 안드로이드 운영체제에서 각각 다른 사용자로 실행된다. (리눅스의 멀티유저와 동일) 앱들이 실행되면 프로세스 형태로 유지되는데, 각각의 앱들은 다른 앱들과 분리되어 실행된다.앱 컴포넌트 앱 컴포넌트는 안드로이드 앱을 구성하는데 필요한 구성요소들이다. 각각의 컴포넌트들은 시스템이나 유저가 들어갈 수 있는 entry point(입구개념)를 제공한다. 그러나 다른 앱에서 다른 앱의 컴포넌트에 직접 접근해 실행을 요청할 수 없기 때문에 안드로이드 시스템을 통해서 실행을 요청한다. 컴포넌트에는 4가지가 존재한다. 액티비티 (Activity) 서비스 (Service) 브로드캐스트 리시버 (Broadcast receiver) 콘텐츠 프로바이더 (Content provider) 각각의 앱 컴포넌트들은 목적이 다르며, 컴포넌트의 Lifecycle(생성과 제거를 의미) 어떻게 정의되어 있는지도 컴포넌트마다 다르다.앱 컴포넌트 활성화 4개의 컴포넌트 중 액티비티, 서비스, 브로드캐스트 리시버는 intent라고 불리는 메시지 전달자에 의해 실행될 수 있으며 런타임때 개별 컴포넌트들을 연결한다. 액티비티와 서비스에서 intent는 특정 작업(보기 또는 보내기)을 담당한다. 즉, 다른 액티비티로 이미지를 보내거나 웹 페이지 열기, 다른 액티비티를 시작하는 등의 요청을 의미한다. 브로드캐스트 리시버에서 intent는 브로드캐스트될 알림을 정의한다. 즉, 배터리가 부족함을 알려주는 브로드캐스트에는 배터리 부족을 나타내는 작업 문자열만 포함된다.액티비티 (Activity) 액티비티는 사용자와 직접 상호작용하는 entry point로 단일 화면을 표현한다. 이메일 앱에서 메일 목록 화면, 메일 읽는 화면, 메일 쓰는 화면이 각각 다른 독립적인 액티비티로 표현된 것이라고 볼 수 있다. 각각의 컴포넌트들은 각자의 entry point를 갖고 있다고 했으므로 앱에서 허용된 액티비티에 다른 앱이 접근할 수 있다. 예를 들어서 이메일 앱에서 카메라에 접근해 사진을 찍고 파일을 업로드 할 수 있거나 갤러리에서 사진을 가져와 업로드하는 것들을 의미한다.서비스 (Service) 서비스는 백그라운드에서 앱이 계속 실행되도록 해주는 범용적인 목적의 entry point이다. 이 컴포넌트는 백그라운드에서 긴 작업을 수행하거나 원격 프로세스에 대한 작업을 수행하기 위해 백그라운드에서 실행된다. 예를 들어서 다른 앱을 사용하는 동안 음악을 듣는다거나 네트워크 관련 활동을 진행한다거나 사용자의 개입이 없는 작업들을 수행한다. 시스템이 서비스를 다루는 형태는 아래 두가지가 있다. Started service : 작업이 완료될 때까지 서비스를 계속 실행하도록 시스템에 전달한다. 즉 위에서 언급한 앱이 최상위에 있지 않더라도 음악을 듣는 등의 작업을 의미한다. Bound service : 다른 앱 또는 시스템에서 서비스를 이용하고자 할 때 실행되는 서비스이며 기본적으로 다른 프로세스에 API를 제공한다. 브로드캐스트 리시버 (Broadcast Receiver) 브로드캐스트 리시버는 시스템이 사용자가 앱을 사용하는 것과 다르게 앱에 이벤트를 전달하거나 앱이 시스템 알람을 받을 수 있도록 한다. 브로드캐스트 리시버도 entry point를 가지고 있으므로 시스템은 현재 실행중이지 않은 앱에도 Broadcast를 보낼 수 있다. 대부분의 Broadcast는 시스템에서 시작되는데, 예를 들어 화면이 꺼졌거나 배터리가 부족하다거나 하는 알람을 전달한다.콘텐츠 프로바이더 (Content Provider) 콘텐츠 프로바이더는 파일 시스템이나 SQLite 데이터베이스, 웹 등의 위치에 데이터를 저장할 수 있도록 관리한다. 예를 들어서 안드로이드 시스템은 사용자의 연락처를 관리할 수 있는 콘텐츠 프로바이더를 제공한다.참고자료" }, { "title": "안드로이드 wrap_content, match_parent", "url": "/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-wrap_content,-match_parent/", "categories": "Android", "tags": "Android", "date": "2022-02-17 00:11:17 +0900", "snippet": "안드로이드 wrap_content, match_parent속성 layout_width, layout_height에 수치값(dp, px), wrap_content, match_parent값을 줄 수 있다.wrap_content layout_width, layout_height속성에 wrap_content가 설정되면 설정된 View의 높이와 넓이가 기본 View의 크기와 같다는 의미가 된다. 만약 TextView와 같은 View에서 글이 길어져 다음줄로 넘어가거나 글씨 크기가 커진다면 컨트롤의 크기 또한 같이 커진다.match_parent layout_width, layout_height속성에 match_parent가 설정되면 설정된 View의 높이와 넓이가 부모의 높이, 넓이와 같은 크기를 가진다는 것이 된다. 단, ConstraintLayout에서는 match_parent 값을 설정하면 안된다. 이미 제약조건(Start_toStartOf, End_toEndOf)에 의해 길이가 정해졌기 때문 match_parent를 써야한다면 0dp로 입력해주어야 한다. 대체로 layout_width에서 match_parent대신 0dp를 사용한다. 두 속성을 사용하는 이유 안드로이드 기기들의 크기가 모두 다양하기 때문에 호환성을 생각해 화면을 구성해야하기 때문 한 가지의 크기로만 구현하게 해두었다면 화면이 더 커지거나 작아졌을 경우 화면이 깨질 가능성이 있다." }, { "title": "안드로이드 레이아웃(ConstraintLayout)의 layout_constraintX_toXOf", "url": "/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83(ConstraintLayout)%EC%9D%98-layout_constraintX_toXOf/", "categories": "Android", "tags": "Android", "date": "2022-02-16 23:20:16 +0900", "snippet": "안드로이드 레이아웃(ConstraintLayout)의 layout_constraintX_toXOf layout을 구성할 때 아래와 같은 코드들을 볼 수 있다. app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot;와 같은 속성도 있는데 굳이 Start를 쓰는 이유는 왼쪽에서 오른쪽(LTR)로 작성되는 영어, 한글은 시작 가장자리는 왼쪽이다. 그러나 아랍어와 같은 언어들은 오른쪽에서 왼쪽(RTL)로 작성되므로 시작 가장자리가 오른쪽이다. 따라서, LTR이든 RTL이든 동일하게 작동할 수 있도록 하기 위함이다. 이러한 이유 때문에 제약 조건을 start, end로 주는 것이다. 제약 조건의 이름의 구성은 layout_constraint&amp;lt;Source&amp;gt;_to&amp;lt;Target&amp;gt;Of로 구성된다. &amp;lt;TextView android:id=&quot;@+id/textview_email&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:text=&quot;&quot; android:textColor=&quot;#CFCFCE&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/textview_desc&quot; /&amp;gt; &amp;lt;View android:id=&quot;@+id/view_line&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;1dp&quot; android:layout_marginTop=&quot;10dp&quot; android:background=&quot;#D4D4D3&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/textview_email&quot; /&amp;gt; 위와 같은 코드에서 아래 &amp;lt;View&amp;gt; 객체의 마지막 줄 app:layout_constraintTop_toBottomOf=&quot;@+id/textview_email&quot;이 뜻하는 것은 &amp;lt;View&amp;gt;의 위쪽(Top)을 @+id/textview_email의 아래쪽(Bottom)에 제약 조건을 걸겠다는 뜻이 된다. " }, { "title": "안드로이드 레이아웃 xmlns:android,app,tools", "url": "/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-xmlns/", "categories": "Android", "tags": "Android", "date": "2022-02-16 23:06:18 +0900", "snippet": "레이아웃 XMLxmlns XML Namespace의 약자 예시 xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns 다음의 문장(android, app, tools)은 스키마나 이러한 단어와 관련된 속성을 이름으로 정의한 것 xmlns:android는 안드로이드 시스템에서 정의한 속성을 의미 속성 xmlns:app외부 라이브러리에 있는 xml에서 속성을 참조 activity_main.xml에서 app:layout_constraintTop_toTopOf 속성을 정의한 후 Ctrl + b를 누르면 어떤 xml을 참조하는 지 알 수 있음 xmlns:tools은 디자인과 관련된 속성들로 구성되어 있음 참조 " }, { "title": "인텐트 및 인텐트 필터", "url": "/posts/%EC%9D%B8%ED%85%90%ED%8A%B8-%EB%B0%8F-%EC%9D%B8%ED%85%90%ED%8A%B8-%ED%95%84%ED%84%B0/", "categories": "Android", "tags": "Intent, Intent Filter", "date": "2022-02-16 20:42:37 +0900", "snippet": "인텐트 (Intent) Intent는 메시징 객체로 다른 앱이나 액티비티로 작업을 요청하는데 사용할 수 있다. 사용 방법은 크게 세 가지로 나눌 수 있다. 액티비티 시작 새로운 액티비티를 시작할 때 Intent에 시작할 액티비티 정보를 담고 startActivity(...)함수로 실행할 수 있다. val intent = Intent(this, SecondActivity::class.java) startActivity(intent) 액티비티에서 결과를 받기 위해서는 registerForActivityResult함수를 이용해 결과를 받을 수 있다. 기존에는 startActivityForResult와 onActivityResult함수를 이용해 결과를 받을 수 있었으나 현재는 메모리 관련 문제로 인해 Deprecated 되어 사용되지 않는다. 서비스 시작 사용자 인터페이스 없이 백그라운드에서 작업을 수행하는 구성 요소로서 API 21 이상부터는 JobScheduler로 서비스를 시작할 수 있지만 그 이하 버전에서는 Service 클래스의 메서드를 사용해 시작할 수 있다. 파일 다운로드와 같은 1회성 작업은 startService에 작업을 수행할 Intent객체를 전달하면 되고, 지속적으로 접근해 무엇인가를 처리해야 하거나 여러 액티비티에서 접근해야할 때는 bindService에 Intent를 전달해주면 된다. 브로드캐스트 전달 시스템과 앱 또는 앱과 앱 간에 이벤트를 주고받을 수 있다. 앱이 브로드캐스트를 받기 위해서는 Receiver를 등록해주어야하며 앱이 브로드캐스트를 보내기 위해서는 sendBroadcast를 이용해 보낼 수 있다. 인텐트 유형명시적 인텐트 대상 앱의 패키지 이름이나 클래스의 이름을 인자로 제공한다. 시작하려고 하는 액티비티나 서비스의 클래스 이름을 알고있기 때문에 일반적으로 앱 안에서 구성 요소를 시작할 때 쓰인다. 아래 예시는 앱 안에 DownloadService라는 서비스 클래스를 구축했다고 가정한다. // Executed in an Activity, so &#39;this&#39; is the Context // The fileUrl is a string URL, such as &quot;http://www.example.com/image.png&quot; val downloadIntent = Intent(this, DownloadService::class.java).apply { data = Uri.parse(fileUrl) } startService(downloadIntent) 암시적 인텐트 수행할 작업을 다른 앱의 구성 요소가 처리할 수 있도록 한다. 안드로이드 시스템에서 다른 앱들의 매니페스트 파일에 선언된 인텐트 필터와 비교해서 작업을 처리할 수 있는 적절한 구성 요소를 표현해준다. 예를들어, 사진첩에서 사진을 선택해 배경화면으로 설정하도록 하는 것을 의미한다. 암시적 인텐트를 처리할 앱이 없을 수 있으므로 resolveActivity함수를 이용해 수신할 앱이 없을 경우 null을 반환한다는 것을 이용해 처리한다. // Create the text message with a string val sendIntent = Intent().apply { action = Intent.ACTION_SEND putExtra(Intent.EXTRA_TEXT, textMessage) type = &quot;text/plain&quot; } // Verify that the intent will resolve to an activity if (sendIntent.resolveActivity(packageManager) != null) { startActivity(sendIntent) } 위 예시는 보내기 전용 및 전달할 데이터의 타입과 메시지의 Intent를 선언하고 resolveActivity를 이용해 이 인텐트를 처리할 앱이 있는지 확인한 후 있다면 해당 앱에 인텐트를 전송한다는 뜻이 된다.인텐트 필터 앱의 매니페스트 파일에 들어가 있는 것으로 해당 구성 요소가 수신하고자 하는 인텐트의 유형을 나타낸다. 단, 보안문제 때문에 API 21 부터는 개발자가 암시적 인텐트로 bindService를 호출하면 예외를 발생시킨다. 매니페스트 파일에 있는 &amp;lt;intent-filter&amp;gt; 태그를 이용하며 내부에는 &amp;lt;action&amp;gt;, &amp;lt;data&amp;gt;, &amp;lt;category&amp;gt; 태그 중 하나 이상을 사용해 인텐트 유형을 지정할 수 있다. &amp;lt;activity android:name=&quot;ShareActivity&quot;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&quot;android.intent.action.SEND&quot;/&amp;gt; &amp;lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&amp;gt; &amp;lt;data android:mimeType=&quot;text/plain&quot;/&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;/activity&amp;gt; 위 예시는 데이터 유형이 텍스트이고 ACTION_SEND 인텐트를 수신할 인텐트 필터가 있는 액티비티 선언이다.[출처] https://developer.android.com/guide/components/intents-filters?hl=ko" }, { "title": "안드로이드의 Activity와 Lifecycle", "url": "/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%9D%98-Activity%EC%99%80-Lifecycle/", "categories": "Android, Activity", "tags": "Android, Activity", "date": "2022-02-14 21:03:30 +0900", "snippet": "마지막 업데이트 : 2022-03-28 17:38:22 +0900안드로이드의 Activity와 Lifecycle특징 액티비티는 유저가 화면을 다루는 것에 초점이 맞춰졌져 있으며, 거의 대부분의 액티비티는 유저와 상호 작용한다. 화면을 구성하는 컴포넌트로서, 이러한 액티비티들이 모여 하나의 앱을 구성한다. 앱을 시작할 때 항상 같은 화면에서 시작되지 않는다. 즉, 앱은 다른 프로그래밍 언어들의 main()과 같은 시작점이 존재하지 않는다. 단지 기본으로 설정되는 액티비티가 있으며 이 액티비티는 앱을 종료하고 다시 실행할 때 표시된다. 알림창에 있는 카카오톡 메시지를 클릭하면 앱의 기본 화면이 아닌 메시지 화면으로 넘어가는 것 현재 액티비티에서 다른 앱의 액티비티를 실행할 수 있다. 카카오톡의 프로필 사진 변경 액티비티에서 사진첩의 특정 액티비티를 실행해 사진을 등록하는 것 액티비티 수명 주기 관리 Activity Lifecycle이라고도 한다. 각각의 액티비티는 Lifecycle이라는 수명 주기가 존재하는데, 액티비티에서 발생하는 여러 상태들을 의미한다. 액티비티들의 상태는 안드로이드 시스템에서 관리하며 특정 이벤트 (실행, 화면 전환, 종료 등)에 대한 콜백이 구현되어 있다. 총 7가지의 콜백이 존재한다. onCreate : 시스템에서 액티비티가 생성될 때 실행되며 필수로 구현되어야 할 부분이다. 이 메서드는 전체 수명 주기 동안 한 번만 발생해야하기 때문에 데이터를 바인딩하거나 뷰(View)와 연결하는 등의 작업을 진행할 때 사용된다. onStart : 액티비티들이 사용자에게 표시되고 사용자와 상호작용할 수 있도록 준비하는 부분이다. onResume : 앱이 사용자와 상호작용할 수 있도록 해주는 부분이며, 어떤 이벤트가 발생하기 전까지 사용자의 입력을 대기한다. onPause : 사용자가 액티비티에서 벗어났을 때(전화가 오거나 홈으로 가는 경우 등) 시스템에서 이 메소드를 먼저 실행한다. 이 메소드는 아주 잠깐 실행되기 때문에 UI관련 리소스와 작업을 완전히 해제하거나 데이터를 저장, 네트워크 호출 등의 부하가 큰 작업은 onStop메소드에 작성하는 것이 좋다. 그리고 멀티윈도우나 Share버튼을 클릭했을 때처럼 UI는 보이지만 포커스를 잃었을 때(상호작용이 불가능할 때) onPause가 호출된다. onStop : 액티비티가 화면에서 완전히 벗어났을 때 실행되는 메소드이며 보여지지 않는 동안 애니메이션 효과 등 필요하지 않은 리소스를 해제하거나 조정할 때 사용할 수 있다. 단, 액티비티가 중단되면 시스템에서 해당 앱을 소멸시킬 수 있는데 이때 onCreate의 매개변수를 이용해 종료 직전의 앱 상태를 복구할 수 있다. onRestart : 액티비티가 중지된 상태에서 다시 시작하려고 할 때, (앱 실행 도중 홈 버튼을 눌렀다가 다시 앱 화면으로 넘어오는 과정) 시스템에서 이 메소드를 호출한다. onDestroy : 액티비티가 소멸되기 전 호출되는 메소드로, 아직 소멸되지 않은 리소스들을 여기서 소멸해주어야 한다. Lifecycle에서 onCreate, onDestroy는 한 번만 호출된다. 전체적인 Life Cycle은 다음과 같다. [출처] https://developer.android.com/reference/kotlin/android/app/Activity https://developer.android.com/guide/components/activities/intro-activities?hl=ko" }, { "title": "[Kotlin] object 키워드", "url": "/posts/Kotlin-object-%ED%82%A4%EC%9B%8C%EB%93%9C/", "categories": "Kotlin", "tags": "Object, 키워드, 코틀린, Kotlin", "date": "2022-02-09 11:36:17 +0900", "snippet": "📚 [Kotlin] object 키워드 object 키워드에는 Object expression(객체 표현식)과 Object declaration(객체 선언) 이라는 개념이 존재한다. 일부 클래스를 약간 수정한 개체를 만들어야할 때 새로운 하위 클래스를 만드는 것 보다 낫다고 판단될 때 사용할 수 있다.🟢 Object expressions (객체 표현식) 객체 표현식은 이름이 정해지지 않은 익명 클래스를 만들 때 사용한다. 익명 클래스란 이름이 정해지지 않았다는 뜻으로 클래스명이 없다. 익명 클래스이므로 클래스를 선언함과 동시에 객체가 생성된다. val helloWorld = object { val hello = &quot;Hello&quot; val world = &quot;World&quot; override fun toString() = &quot;$hello $world&quot; } fun main() { println(helloWorld) } 위 코드에서 object 다음의 {부터 }까지가 익명 클래스가 된다. 이런 익명 클래스들은 일회성으로 사용할 필요가 있을 때 유용하다. 처음부터 익명 클래스를 구현하거나 기존 클래스나 인터페이스를 상속받아 구현할 수 있다. 위 코드는 처음부터 익명 클래스를 구현한 코드이다. 익명 클래스의 인스턴스는 표현식이기 때문에 익명 객체라고도 한다.🟢 처음부터 익명 클래스 구현 처음부터 객체 표현식을 이용한 익명 클래스를 구현하게 되면 타입이 선언되어있지 않기 때문에 Any로 취급된다. 따라서 아래와 같은 코드는 결국 Any클래스에서 test라는 메소드가 없기 때문에 에러가 발생하게 된다. val helloWorld = object { fun test() = println(&quot;test&quot;) } fun main() { helloWorld.test() // 에러발생 } 사용자가 정의한 메서드나 속성에 접근하려면 아래와 같이 private나 local에서 사용이 가능하다. private val helloWorld2 = object { fun test() = println(&quot;helloWorld2&quot;) } fun main() { val helloWorld3 = object { fun test() = println(&quot;helloWorld3&quot;) } println(helloWorld2.test()) // 접근가능 println(helloWorld3.test()) // 접근가능 } 왜 2번은 사용자가 정의한 메서드나 속성에 접근이 가능한지는 잘 모르겠다.. 🟢 상속을 이용한 익명 클래스 구현 기존에 구현된 클래스나 인터페이스를 상속받아 익명 클래스로 구현할 수 있다. window.addMouseListener(object : MouseAdapter() { override fun mouseClicked(e: MouseEvent) { /*...*/ } override fun mouseEntered(e: MouseEvent) { /*...*/ } }) 🟢 Object declarations (객체 선언) 싱글톤(Singleton) 패턴을 사용할 때 이용할 수 있는 기능중의 하나이다. 싱글톤이란 프로그램이 실행 도중에 생성되는 객체는 단 하나 라는 점 object DataProviderManager { fun registerDataProvider(provider: DataProvider) { // ... } val allDataProviders: Collection&amp;lt;DataProvider&amp;gt; get() = // ... } 다음과 같이 사용할 수 있다. DataProviderManager.registerDataProvider(...) 출처 https://kotlinlang.org/docs/object-declarations.html#object-expressions" }, { "title": "[BOJ 17478] 재귀함수가 뭔가요?", "url": "/posts/17478-%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EA%B0%80-%EB%AD%94%EA%B0%80%EC%9A%94/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 17478", "date": "2022-02-09 10:30:08 +0900", "snippet": "재귀함수가 뭔가요? (17478번)https://www.acmicpc.net/problem/17478헤맸던 부분 ’-‘ 문자가 아니라 ‘_’ 문자였다. 긴 문장에서도 각 줄마다 ‘__‘를 넣어줘야하는데 그 부분을 놓쳤다. 위 둘 다 문제를 제대로 읽지않아 발생한 문제…풀이방법import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;public class Main { /* 마지막에서만 &quot;재귀함수는 자기 자신을 호출하는 함수라네&quot; 문자열 출력 */ private static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); sb.append(&quot;어느 한 컴퓨터공학과 학생이 유명한 교수님을 찾아가 물었다.&quot;).append(&#39;\\n&#39;); recursive(n, 0); System.out.println(sb); } private static void recursive(int n, int under) { if (n == 0) { repeat(under); sb.append(&quot;\\&quot;재귀함수가 뭔가요?\\&quot;&quot;).append(&#39;\\n&#39;); repeat(under); sb.append(&quot;\\&quot;재귀함수는 자기 자신을 호출하는 함수라네\\&quot;&quot;).append(&#39;\\n&#39;); repeat(under); sb.append(&quot;라고 답변하였지.&quot;).append(&#39;\\n&#39;); return; } repeat(under); sb.append(&quot;\\&quot;재귀함수가 뭔가요?\\&quot;&quot;).append(&#39;\\n&#39;); repeat(under); sb.append(&quot;\\&quot;잘 들어보게. 옛날옛날 한 산 꼭대기에 이세상 모든 지식을 통달한 선인이 있었어.\\n&quot;); repeat(under); sb.append(&quot;마을 사람들은 모두 그 선인에게 수많은 질문을 했고, 모두 지혜롭게 대답해 주었지.\\n&quot;); repeat(under); sb.append(&quot;그의 답은 대부분 옳았다고 하네. 그런데 어느 날, 그 선인에게 한 선비가 찾아와서 물었어.\\&quot;\\n&quot;); recursive(n-1, under + 1); repeat(under); sb.append(&quot;라고 답변하였지.&quot;).append(&#39;\\n&#39;); } private static void repeat(int under) { for(int i=0; i&amp;lt;under; i++) { sb.append(&quot;____&quot;); } }}" }, { "title": "[BOJ 1074] Z 문제풀이", "url": "/posts/1074-Z/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 1074", "date": "2022-02-06 17:20:36 +0900", "snippet": "Z (1074번)https://www.acmicpc.net/problem/1074풀이방법 r, c가 몇 사분면 위에 있는지 확인 해당 사분면의 시작번호 파악 8x8 에서는 4x4가 하나의 사분면이므로 1사분면 : 0~15 2사분면 : 16~31 3사분면 : 32~47 4사분면 : 48~63 해당사분면의 시작 번호 : 2^n-1 + 2^n-1 * (해당사분면 - 1) r, c값을 현재 사분면을 기준으로 뺌 ex) 2^2 x 2^2 일 때 (3,2)면 4사분면이고 해당 면에서는 (3,2)가 (1, 0)이 됨 즉, r, c를 2^n-1로 나눈 나머지를 구하면 됨 1~3과정을 재귀로 반복해서 2x2 배열이 될 때까지 나누고 시작값에 x+2y하면 정답이 됨import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int n = (int)Math.pow(2, Integer.parseInt(st.nextToken())); int y = Integer.parseInt(st.nextToken()); int x = Integer.parseInt(st.nextToken()); recursive(0, x, y, n); } private static void recursive(int startValue, int x, int y, int nn) { if (nn == 2) { System.out.println(startValue + (x + 2*y)); return; } int quadrant = getQuadrant(x, y, nn); int tmpStartValue = startValue + (nn&amp;gt;&amp;gt;1) * (nn&amp;gt;&amp;gt;1) * (quadrant - 1); recursive(tmpStartValue, x % (nn&amp;gt;&amp;gt;1), y % (nn&amp;gt;&amp;gt;1), nn&amp;gt;&amp;gt;1); } private static int getQuadrant(int x, int y, int nn) { if (x &amp;lt; nn&amp;gt;&amp;gt;1 &amp;amp;&amp;amp; y &amp;lt; nn&amp;gt;&amp;gt;1) { return 1; } else if (x &amp;gt;= nn&amp;gt;&amp;gt;1 &amp;amp;&amp;amp; y &amp;lt; nn&amp;gt;&amp;gt;1) { return 2; } else if (x &amp;lt; nn&amp;gt;&amp;gt;1 &amp;amp;&amp;amp; y &amp;gt;= nn&amp;gt;&amp;gt;1) { return 3; } else { return 4; } }}" }, { "title": "[BOJ 11729] 하노이 탑 이동 순서", "url": "/posts/11729-%ED%95%98%EB%85%B8%EC%9D%B4-%ED%83%91-%EC%9D%B4%EB%8F%99-%EC%88%9C%EC%84%9C/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 11729", "date": "2022-02-05 17:45:28 +0900", "snippet": "하노이 탑 이동 순서 (11729번)https://www.acmicpc.net/problem/11729풀이방법 재귀로 풀어야 하는 문제로, N번째 원판을 3번째 기둥에 넣기 위해서는 N-1번째 원판을 2번째 기둥에 넣어야하고 2번째 기둥에 있는 원판을 1개만 남겨두고 다시 1번째 기둥에 옮긴 후 1개만 남은 원판을 3번째 기둥에 넣는다. 위 과정을 계속 반복하면 된다. 재귀 문제는 수학적 귀납법이 제일 중요한데 문제를 직접 디버깅하려고 하면 점점 산으로 가기 때문에 나름대로 공식을 세우고 구현을 해야한다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;public class Main { static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); sb.append(pow(2, n) - 1).append(&#39;\\n&#39;); hanoi(1, 2, 3, n); System.out.println(sb); } private static int pow(int a, int b) { int n = 0; int result = 1; while (n++ != b) { result *= a; } return result; } private static void hanoi(int from, int mid, int to, int n) { if (n == 1) { sb.append(from).append(&#39; &#39;).append(to).append(&#39;\\n&#39;); return; } hanoi(from, to, mid, n-1); sb.append(from).append(&#39; &#39;).append(to).append(&#39;\\n&#39;); hanoi(mid, from, to, n-1); }}" }, { "title": "[BOJ 7562] 나이트의 이동", "url": "/posts/7562-%EB%82%98%EC%9D%B4%ED%8A%B8%EC%9D%98-%EC%9D%B4%EB%8F%99/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 7562", "date": "2022-02-04 21:33:22 +0900", "snippet": "나이트의 이동 (7562번)https://www.acmicpc.net/problem/7562풀이방법 전형적인 BFS 문제이다. X, Y가 움직일 수 있는 모든 경우의 수 8가지를 이용해 문제를 해결한다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int T = Integer.parseInt(br.readLine()); StringTokenizer st; int I = 0; StringBuilder sb = new StringBuilder(); while (T-- &amp;gt; 0) { I = Integer.parseInt(br.readLine()); int[] curPos = new int[2]; st = new StringTokenizer(br.readLine()); curPos[0] = Integer.parseInt(st.nextToken()); curPos[1] = Integer.parseInt(st.nextToken()); st = new StringTokenizer(br.readLine()); int[] targetPos = new int[2]; targetPos[0] = Integer.parseInt(st.nextToken()); targetPos[1] = Integer.parseInt(st.nextToken()); int[][] dist = new int[I+1][I+1]; initDist(dist); if (curPos[0] == targetPos[0] &amp;amp;&amp;amp; curPos[1] == targetPos[1]) { sb.append(0).append(&#39;\\n&#39;); } else { bfs(dist, curPos, targetPos, I); sb.append(dist[targetPos[1]][targetPos[0]]).append(&#39;\\n&#39;); } } System.out.println(sb); } private static void initDist(int[][] dist) { for(int i=0; i&amp;lt;dist.length; i++) { for (int j=0; j&amp;lt;dist.length; j++) { dist[i][j] = -1; } } } private static void bfs(int[][] dist, int[] curPos, int[] targetPos, int I) { Queue&amp;lt;int[]&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(curPos); dist[curPos[1]][curPos[0]] = 0; int[] cur; int[] xPos = {-1, -1, 1, 1, -2, -2, 2, 2}; int[] yPos = {2, -2, 2, -2, 1, -1, 1, -1}; int dx = 0; int dy = 0; while (!queue.isEmpty()) { cur = queue.poll(); for(int i=0; i&amp;lt;8; i++) { dx = cur[0] + xPos[i]; dy = cur[1] + yPos[i]; if (dx &amp;lt; 0 || dx &amp;gt;= I || dy &amp;lt; 0 || dy &amp;gt;= I) continue; if (dist[dy][dx] != -1) continue; dist[dy][dx] = dist[cur[1]][cur[0]] + 1; if (dx == targetPos[0] &amp;amp;&amp;amp; dy == targetPos[1]) return; queue.add(new int[] { dx, dy }); } } }}" }, { "title": "[BOJ 7569] 토마토", "url": "/posts/7569-%ED%86%A0%EB%A7%88%ED%86%A0/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 7569", "date": "2022-02-04 20:40:02 +0900", "snippet": "토마토 (7569번)https://www.acmicpc.net/problem/7569풀이방법 숫자를 입력받을 때 익은 토마토의 좌표를 Queue에 넣는다. Queue에서 하나씩 빼면서 위,아래,상,하,좌,우에 현재값 +1 한다. 방문하지 않은 곳은 -1로 설정한다. +1할때마다 최대값을 구한다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;public class Main { static Queue&amp;lt;int[]&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); static int[][][] map; static int[][][] dist; static int zeroCount; static int max = 0; static int M = 0; static int N = 0; static int H = 0; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); M = Integer.parseInt(st.nextToken()); N = Integer.parseInt(st.nextToken()); H = Integer.parseInt(st.nextToken()); map = new int[H][N][M]; dist = new int[H][N][M]; zeroCount = 0; for(int i=0; i&amp;lt;H; i++) { for (int j=0; j&amp;lt;N; j++) { st = new StringTokenizer(br.readLine()); for (int k=0; k&amp;lt;M; k++) { map[i][j][k] = Integer.parseInt(st.nextToken()); if (map[i][j][k] == 0) { dist[i][j][k] = -1; zeroCount++; } if (map[i][j][k] == 1) { dist[i][j][k] = 0; queue.add(new int[] { k, j, i }); } } } } if (zeroCount == 0) { System.out.println(0); return; } bfs(); if (zeroCount != 0) System.out.println(-1); else System.out.println(max); } private static void bfs() { int[] cur; int[] xPos = {1, 0, -1, 0, 0, 0}; int[] yPos = {0, 1, 0, -1, 0, 0}; int[] zPos = {0, 0, 0, 0, -1, 1}; int dx = 0; int dy = 0; int dz = 0; while (!queue.isEmpty()) { cur = queue.poll(); for(int i=0; i&amp;lt;6; i++) { dx = cur[0] + xPos[i]; dy = cur[1] + yPos[i]; dz = cur[2] + zPos[i]; if (dx &amp;lt; 0 || dx &amp;gt;= M || dy &amp;lt; 0 || dy &amp;gt;= N || dz &amp;lt; 0 || dz &amp;gt;= H) continue; if (dist[dz][dy][dx] != -1) continue; dist[dz][dy][dx] = dist[cur[2]][cur[1]][cur[0]] + 1; queue.add(new int[] { dx, dy, dz }); max = Math.max(max, dist[dz][dy][dx]); zeroCount--; } } }}" }, { "title": "[BOJ 10026] 적록색약", "url": "/posts/10026-%EC%A0%81%EB%A1%9D%EC%83%89%EC%95%BD/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 10026", "date": "2022-02-03 15:23:15 +0900", "snippet": "적록색약 (10026번)https://www.acmicpc.net/problem/10026뻘짓 단순히 생각하면 되는데 어렵게 생각했다. 적록색약인 경우 R인지 G인지 확인하고 상하좌우의 값이 R 또는 G인 경우에만 더해주는 방식으로 구현해보려했는데 잘 되지 않았다.풀이방법 BFS를 이용해 적록색약이 아닐 때의 개수를 센다. R을 G로 바꾸게 되면 적록색약인 사람이 보는 것과 동일하다. R을 G로 바꾼 후 다시 BFS를 이용해 적록색약일 때의 개수를 센다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;public class Main { static char[][] map; static boolean[][] visited; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); map = new char[N][N]; visited = new boolean[N][N]; for (int i=0; i&amp;lt;N; i++) { String str = br.readLine(); for (int j=0; j&amp;lt;N; j++) { map[i][j] = str.charAt(j); } } int rgbCount = 0; int rrbCount = 0; for (int i=0; i&amp;lt;N; i++) { for (int j=0; j&amp;lt;N; j++) { if (!visited[i][j]) { char c = map[i][j]; bfs(c, j, i, N); rgbCount++; } } } changeMap(N); visited = new boolean[N][N]; for (int i=0; i&amp;lt;N; i++) { for (int j=0; j&amp;lt;N; j++) { if (!visited[i][j]) { char c = map[i][j]; bfs(c, j, i, N); rrbCount++; } } } StringBuilder sb = new StringBuilder(); sb.append(rgbCount).append(&#39; &#39;).append(rrbCount); System.out.println(sb); } public static void changeMap(int N) { for (int i=0; i&amp;lt;N; i++) { for (int j=0; j&amp;lt;N; j++) { if (map[i][j] == &#39;R&#39;) map[i][j] = &#39;G&#39;; } } } public static void bfs(char c, int x, int y, int n) { Queue&amp;lt;int[]&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(new int[] { x, y }); visited[y][x] = true; int[] cur; int[] xPos = {1, 0, -1, 0}; int[] yPos = {0, 1, 0, -1}; int dx = 0; int dy = 0; while (!queue.isEmpty()) { cur = queue.poll(); for (int i=0; i&amp;lt;4; i++) { dx = cur[0] + xPos[i]; dy = cur[1] + yPos[i]; if (dx &amp;lt; 0 || dx &amp;gt;= n || dy &amp;lt; 0 || dy &amp;gt;= n) continue; if (visited[dy][dx] || map[dy][dx] != c) continue; visited[dy][dx] = true; queue.add(new int[] { dx, dy }); } } }}" }, { "title": "[BOJ 1012] 유기농 배추", "url": "/posts/1012-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 1012", "date": "2022-02-03 14:31:58 +0900", "snippet": "유기농 배추 (1012번)https://www.acmicpc.net/problem/1012풀이방법 전형적인 BFS문제로, 배추가 있으면서 방문하지 않은 곳인지 확인한다. 해당 위치부터 상,하,좌,우 위치에 있는 값을 확인해 방문했다는 표시를 남긴다. 이렇게 되면 이미 방문한 곳은 제외하므로 BFS가 끝나면 벌레의 개수를 1증가시킨다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.*;public class Main { static boolean[][] visited; static Queue&amp;lt;int[]&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); static int[][] map; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = null; int T = Integer.parseInt(br.readLine()); StringBuilder sb = new StringBuilder(); int bugCount = 0; while (T-- &amp;gt; 0) { st = new StringTokenizer(br.readLine()); int M = Integer.parseInt(st.nextToken()); int N = Integer.parseInt(st.nextToken()); int K = Integer.parseInt(st.nextToken()); map = new int[N][M]; visited = new boolean[N][M]; for(int i=0; i&amp;lt;K; i++) { st = new StringTokenizer(br.readLine()); int X = Integer.parseInt(st.nextToken()); int Y = Integer.parseInt(st.nextToken()); map[Y][X] = 1; } for(int i=0; i&amp;lt;N; i++) { for (int j=0; j&amp;lt;M; j++) { if (map[i][j] == 1 &amp;amp;&amp;amp; !visited[i][j]) { bfs(j, i, M, N); bugCount++; } } } sb.append(bugCount).append(&#39;\\n&#39;); bugCount = 0; } System.out.println(sb); } public static void bfs(int x, int y, int m, int n) { queue.add(new int[] { x, y }); visited[y][x] = true; int[] cur; int[] xPos = {1, 0, -1, 0}; int[] yPos = {0, 1, 0, -1}; int dx = 0; int dy = 0; while (!queue.isEmpty()) { cur = queue.poll(); for (int i=0; i&amp;lt;4; i++) { dx = cur[0] + xPos[i]; dy = cur[1] + yPos[i]; if (dx &amp;lt; 0 || dx &amp;gt;= m || dy &amp;lt; 0 || dy &amp;gt;= n) continue; if (visited[dy][dx] || map[dy][dx] != 1) continue; visited[dy][dx] = true; queue.add(new int[] { dx, dy }); } } }}" }, { "title": "[BOJ 1697] 숨바꼭질", "url": "/posts/1697-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 1697", "date": "2022-02-02 17:48:27 +0900", "snippet": "숨바꼭질 (1697번)https://www.acmicpc.net/problem/1697풀이방법 BFS, DP로 풀 수 있는 문제이다. 거리 배열을 넉넉하게 200,000으로 설정했다. 문제는 100,000까지지만 100,000보다 크게 갔다가 돌아올 수 있으므로 +1, -1, *2를 하면서 해당 위치에 값을 입력해주었다. 그렇게되면 현재 위치에서 해당 위치까지 몇 번 움직여야되는지에 대한 답이 나오기 때문이다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.Arrays;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); int K = Integer.parseInt(st.nextToken()); int[] dist = new int[100_000 * 2]; Arrays.fill(dist, -1); Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(N); dist[N] = 0; int cur = 0; int origin = 0; while (dist[K] == -1) { origin = queue.poll(); cur = origin - 1; if (cur &amp;gt;= 0 &amp;amp;&amp;amp; cur &amp;lt; 100_000*2 &amp;amp;&amp;amp; dist[cur] == -1) { dist[cur] = dist[origin]+1; queue.add(cur); } cur = origin + 1; if (cur &amp;gt;= 0 &amp;amp;&amp;amp; cur &amp;lt; 100_000*2 &amp;amp;&amp;amp; dist[cur] == -1) { dist[cur] = dist[origin]+1; queue.add(cur); } cur = origin * 2; if (cur &amp;gt;= 0 &amp;amp;&amp;amp; cur &amp;lt; 100_000*2 &amp;amp;&amp;amp; dist[cur] == -1) { dist[cur] = dist[origin]+1; queue.add(cur); } } System.out.println(dist[K]); }}" }, { "title": "[BOJ 4179] 불!", "url": "/posts/4179-%EB%B6%88!/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 4179", "date": "2022-02-02 16:31:31 +0900", "snippet": "불! (4179번)https://www.acmicpc.net/problem/4179풀이방법 지훈과 불의 거리 BFS를 이용해 문제를 해결한다. 불의 거리를 BFS로 구한다. 지훈의 거리를 BFS로 구한다. 단, 거리를 구하다가 X, Y의 범위에서 벗어날 경우 해당 위치가 정답이 될 가능성이 있다. 정답이 되기 위해서는 해당 위치에 불이 없어야하므로 범위에서 벗어날 때 불이 있는 자리인지 확인한다. import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int y = Integer.parseInt(st.nextToken()); int x = Integer.parseInt(st.nextToken()); int[][] map = new int[y][x]; int[][] jDist = new int[y][x]; int[][] fDist = new int[y][x]; Queue&amp;lt;int[]&amp;gt; jihoon = new LinkedList&amp;lt;&amp;gt;(); Queue&amp;lt;int[]&amp;gt; fire = new LinkedList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; y; i++) { StringBuilder str = new StringBuilder(br.readLine()); for (int j = 0; j &amp;lt; x; j++) { jDist[i][j] = -1; fDist[i][j] = -1; if (str.charAt(j) == &#39;#&#39;) map[i][j] = 0; else if (str.charAt(j) == &#39;.&#39;) map[i][j] = 1; else if (str.charAt(j) == &#39;J&#39;) { jihoon.add(new int[]{i, j}); map[i][j] = 2; jDist[i][j] = 1; } else if (str.charAt(j) == &#39;F&#39;) { fire.add(new int[]{i, j}); map[i][j] = 2; fDist[i][j] = 1; } } } int[] directX = {1, 0, -1, 0}; int[] directY = {0, 1, 0, -1}; int dx = 0; int dy = 0; int[] cur; while (!fire.isEmpty()) { cur = fire.poll(); for (int i = 0; i &amp;lt; 4; i++) { dx = cur[1] + directX[i]; dy = cur[0] + directY[i]; if (dx &amp;lt; 0 || dx &amp;gt;= x || dy &amp;lt; 0 || dy &amp;gt;= y) continue; if (map[dy][dx] == 1 &amp;amp;&amp;amp; fDist[dy][dx] == -1) { fDist[dy][dx] = fDist[cur[0]][cur[1]] + 1; fire.add(new int[]{dy, dx}); } } } while (!jihoon.isEmpty()) { cur = jihoon.poll(); for (int i = 0; i &amp;lt; 4; i++) { dx = cur[1] + directX[i]; dy = cur[0] + directY[i]; if ((dx &amp;lt; 0 || dx &amp;gt;= x || dy &amp;lt; 0 || dy &amp;gt;= y)) { if ((fDist[cur[0]][cur[1]] &amp;gt; jDist[cur[0]][cur[1]]) || fDist[cur[0]][cur[1]] == -1) { System.out.println(jDist[cur[0]][cur[1]]); return; } continue; } if (map[dy][dx] == 1 &amp;amp;&amp;amp; jDist[dy][dx] == -1) { jDist[dy][dx] = jDist[cur[0]][cur[1]] + 1; jihoon.add(new int[]{dy, dx}); } } } System.out.println(&quot;IMPOSSIBLE&quot;); }}" }, { "title": "[BOJ 7576] 토마토", "url": "/posts/7576-%ED%86%A0%EB%A7%88%ED%86%A0/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 7576", "date": "2022-02-01 15:38:31 +0900", "snippet": "Last Update : 2022-06-22 00:26:07 +0900토마토 (7576번)https://www.acmicpc.net/problem/7576풀이방법 숫자를 입력받을 때 익은 토마토의 좌표를 Queue에 넣는다. Queue에서 하나씩 빼면서 상하좌우에 현재값 +1 한다. 방문하지 않은 곳은 -1로 설정한다. +1할때마다 최대값을 구한다.Javaimport java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int M = Integer.parseInt(st.nextToken()); int N = Integer.parseInt(st.nextToken()); int[][] map = new int[N][M]; int[][] dist = new int[N][M]; int zeroCount = 0; Queue&amp;lt;int[]&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); for(int i=0; i&amp;lt;N; i++) { st = new StringTokenizer(br.readLine()); for(int j=0; j&amp;lt;M; j++) { map[i][j] = Integer.parseInt(st.nextToken()); dist[i][j] = -1; if (map[i][j] == 1) queue.add(new int[]{i, j}); if (map[i][j] == 0) zeroCount++; } } int[] xPos = {1, 0, -1, 0}; int[] yPos = {0, 1, 0, -1}; int dx = 0; int dy = 0; int max = 0; while (!queue.isEmpty()) { int[] cur = queue.poll(); for (int i=0; i&amp;lt;4; i++) { dx = cur[1] + xPos[i]; dy = cur[0] + yPos[i]; if (dx &amp;lt; 0 || dx &amp;gt;= M || dy &amp;lt; 0 || dy &amp;gt;= N) continue; if (map[dy][dx] == 0 &amp;amp;&amp;amp; dist[dy][dx] == -1) { dist[dy][dx] = dist[cur[0]][cur[1]]+1; max = Math.max(dist[dy][dx], max); zeroCount--; queue.add(new int[] { dy, dx }); } } } if (zeroCount != 0) System.out.println(-1); else if(max == 0) System.out.println(0); else System.out.println(max+1); }}C++#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;int main() { ios::sync_with_stdio(0); cin.tie(0); int m, n; int map[1002][1002]; int dist[1002][1002]; cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Q; int dayCount = 0; int tomato_X = 0; for (int i=0; i&amp;lt;n; i++) { for (int j=0; j&amp;lt;m; j++) { cin &amp;gt;&amp;gt; map[i][j]; if (map[i][j] == 0) tomato_X++; else if (map[i][j] == 1) Q.push(pair(j, i)); dist[i][j] = -1; } } int dx[] = {1, 0, -1, 0}; int dy[] = {0, 1, 0, -1}; while (!Q.empty()) { pair&amp;lt;int, int&amp;gt; data = Q.front(); Q.pop(); for (int j=0; j&amp;lt;4; j++) { int x = data.first + dx[j]; int y = data.second + dy[j]; // m*n 범위에서 벗어난 경우 if (x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= m || y &amp;gt;= n) continue; // 토마토가 없는 경우 // 토마토가 이미 익은 경우 if (map[y][x] == 1 || map[y][x] == -1) continue; dist[y][x] = dist[data.second][data.first]+1; map[y][x] = 1; Q.push(pair(x, y)); dayCount = max(dist[y][x], dayCount); tomato_X--; } } if (tomato_X != 0) { cout &amp;lt;&amp;lt; -1; } else if (dayCount == 0) { cout &amp;lt;&amp;lt; 0; } else { cout &amp;lt;&amp;lt; dayCount + 1; } return 0;}" }, { "title": "[BOJ 2178] 미로 탐색", "url": "/posts/2178-%EB%AF%B8%EB%A1%9C-%ED%83%90%EC%83%89/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 2178", "date": "2022-02-01 14:38:12 +0900", "snippet": "Last Update : 2022-06-21 00:11:42 +0900 C++로 재풀이미로 탐색 (2178번)https://www.acmicpc.net/problem/2178풀이방법 BFS(너비우선탐색)를 이용한 문제풀이 무조건 (1,1)에서 (N,M)까지라고 하였으므로 어디서부터 시작해야하는지 찾을 필요 없음 시작점에서의 거리를 계산함 현재값에서 상하좌우를 확인하고, 현재 거리값에 +1한 값을 상하좌우의 방문하지않았으며 0이 아닌 곳에 입력 distance배열에서 좌표의 값이 -1인 경우 방문하지 않은 곳Javaimport java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); int[][] map = new int[N][M]; int[][] distance = new int[N][M]; for(int i=0; i&amp;lt;N; i++) { String str = br.readLine(); for(int j=0; j&amp;lt;M; j++) { map[i][j] = str.charAt(j) - &#39;0&#39;; distance[i][j] = -1; } } Queue&amp;lt;int[]&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); int[] directX = {1, 0, -1, 0}; int[] directY = {0, 1, 0, -1}; int curX = 0; int curY = 0; int dx = 0; int dy = 0; queue.add(new int[] { 0, 0 }); distance[0][0] = 1; while (!queue.isEmpty()) { int[] cur = queue.poll(); curX = cur[0]; curY = cur[1]; for(int i=0; i&amp;lt;4; i++) { dx = curX + directX[i]; dy = curY + directY[i]; if (dx &amp;lt; 0 || dx &amp;gt;= M || dy &amp;lt; 0 || dy &amp;gt;= N) continue; if (map[dy][dx] != 0 &amp;amp;&amp;amp; distance[dy][dx] == -1) { distance[dy][dx] = distance[curY][curX]+1; queue.add(new int[] { dx, dy }); } } } System.out.println(distance[N-1][M-1]); }}C++#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;int main() { ios::sync_with_stdio(0); cin.tie(0); int n, m; string map[102]; int visit[102][102]; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Q; for (int i=0; i&amp;lt;n; i++) { cin &amp;gt;&amp;gt; map[i]; } int dx[4] = { 1, 0, -1, 0 }; int dy[4] = { 0, 1, 0, -1 }; visit[0][0] = 1; Q.push(pair(0, 0)); while (!Q.empty()) { pair&amp;lt;int, int&amp;gt; data = Q.front(); Q.pop(); for (int i=0; i&amp;lt;4; i++) { int x = data.first + dx[i]; int y = data.second + dy[i]; if (x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= n || y &amp;gt;= m) continue; if (visit[x][y] &amp;gt; 0 || map[x][y] == &#39;0&#39;) continue; visit[x][y] = visit[data.first][data.second] + 1; Q.push(pair(x, y)); } } cout &amp;lt;&amp;lt; visit[n-1][m-1];}" }, { "title": "[BOJ 1926] 그림", "url": "/posts/1926-%EA%B7%B8%EB%A6%BC/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 1926", "date": "2022-02-01 12:33:08 +0900", "snippet": "그림 (1926번)https://www.acmicpc.net/problem/1926풀이방법 Queue를 이용해 방문하지 않았으면서 해당 위치의 값이 1인 좌표를 추가한다. 현재 위치가 방문하지 않았고 1이라면 넓이를 1 증가시킨 후 Queue에 넣는다. poll로 Queue에 있는 값을 가져와 상하좌우 비교한다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int y = Integer.parseInt(st.nextToken()); int x = Integer.parseInt(st.nextToken()); int[][] paper = new int[y][x]; boolean[][] visited = new boolean[y][x]; int[] directX = {1, 0, -1, 0}; int[] directY = {0, 1, 0, -1}; for(int i=0; i&amp;lt;y; i++) { st = new StringTokenizer(br.readLine()); for(int j=0; j&amp;lt;x; j++) { paper[i][j] = Integer.parseInt(st.nextToken()); } } Queue&amp;lt;int[]&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); int dx = 0; int dy = 0; int curX = 0; int curY = 0; int countOfPicture = 0; int maxAreaOfPicture = 0; int areaOfPicture = 0; for(int i=0; i&amp;lt;y; i++) { for(int j=0; j&amp;lt;x; j++) { if (visited[i][j] || paper[i][j] == 0) continue; queue.add(new int[]{i, j}); visited[i][j] = true; countOfPicture++; while (!queue.isEmpty()) { areaOfPicture++; int[] pos = queue.poll(); curX = pos[1]; curY = pos[0]; for(int k=0; k&amp;lt;4; k++) { dx = curX + directX[k]; dy = curY + directY[k]; if (dx &amp;lt; 0 || dx &amp;gt;= x || dy &amp;lt; 0 || dy &amp;gt;= y) continue; if (visited[dy][dx] || paper[dy][dx] != 1) continue; queue.add(new int[]{dy, dx}); visited[dy][dx] = true; } } maxAreaOfPicture = Math.max(maxAreaOfPicture, areaOfPicture); areaOfPicture = 0; } } System.out.println(countOfPicture); System.out.println(maxAreaOfPicture); }}" }, { "title": "[BOJ 10773] 제로", "url": "/posts/10773-%EC%A0%9C%EB%A1%9C/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 10773", "date": "2022-01-27 09:59:54 +0900", "snippet": "제로 (10773번)https://www.acmicpc.net/problem/10773풀이방법 스택을 이용해 입력값이 0인 경우 pop을 하고 0이 아니라면 해당 값을 push한다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;public class Main { static class Stack { int pos = 0; int countOfData = 0; int[] array = null; public Stack(int size) { array = new int[size]; } public int pop() { countOfData--; int rData = array[--pos]; array[pos] = 0; return rData; } public void push(int c) { array[pos++] = c; countOfData++; } public boolean isEmpty() { return (countOfData == 0); } public int size() { return countOfData; } } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int K = Integer.parseInt(br.readLine()); Stack stack = new Stack(K); int value = 0; int sum = 0; while (K-- &amp;gt; 0) { value = Integer.parseInt(br.readLine()); if (value == 0 &amp;amp;&amp;amp; !stack.isEmpty()) sum -= stack.pop(); else { sum += value; stack.push(value); } } System.out.println(sum); }}" }, { "title": "[BOJ 5397] 키로거", "url": "/posts/5397-%ED%82%A4%EB%A1%9C%EA%B1%B0/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 5397", "date": "2022-01-27 09:57:07 +0900", "snippet": "키로거 (5397번)https://www.acmicpc.net/problem/5397풀이방법 스택을 구현한다. 처음에는 자바 내장 클래스를 이용했지만 속도가 느려서 배열로 직접 간단히 구현했다. 1000ms -&amp;gt; 740ms로 줄어들었다. 입력 데이터를 하나씩 분석한다. &amp;lt;문자일 경우 스택에서 pop한 후 임시 스택에 보관한다. &amp;gt;문자일 경우 임시 스택에서 pop한 후 스택에 보관한다. -문자일 경우 스택에서 제거한다. 역순으로 저장되므로 반환할 때 revese메소드를 이용해 역으로 출력한다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;public class Main { static class Stack { int pos = 0; int countOfData = 0; char[] array = null; public Stack(int size) { array = new char[size]; } public char pop() { countOfData--; char rData = array[--pos]; array[pos] = 0; return rData; } public void push(char c) { array[pos++] = c; countOfData++; } public boolean isEmpty() { return (countOfData == 0); } public int size() { return countOfData; } } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int T = Integer.parseInt(br.readLine()); char[] input = null; StringBuilder sb = new StringBuilder(); while (T-- &amp;gt; 0) { input = br.readLine().toCharArray(); sb.append(keylog(input)).append(&#39;\\n&#39;); } System.out.println(sb); } private static String keylog(char[] input) { Stack keylogger = new Stack(input.length); Stack tmpInputs = new Stack(input.length); for(int i=0; i&amp;lt;input.length; i++) { switch (input[i]) { case &#39;&amp;lt;&#39;: if (keylogger.size() == 0) break; tmpInputs.push(keylogger.pop()); break; case &#39;&amp;gt;&#39;: if (tmpInputs.isEmpty()) break; keylogger.push(tmpInputs.pop()); break; case &#39;-&#39;: if (keylogger.isEmpty()) break; keylogger.pop(); break; default: keylogger.push(input[i]); break; } } StringBuilder sb = new StringBuilder(); while (!tmpInputs.isEmpty()) keylogger.push(tmpInputs.pop()); while (!keylogger.isEmpty()) sb.append(keylogger.pop()); return sb.reverse().toString(); }}" }, { "title": "프로세스 메모리 구조", "url": "/posts/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0/", "categories": "CS", "tags": "CS, 프로세스, 메모리 구조", "date": "2022-01-23 14:58:23 +0900", "snippet": "프로세스 메모리 구조메모리 구조스택(Stack) 함수의 파라미터, 함수 반환 위치, 지역변수 등을 임시로 저장하는 공간으로, 함수가 리턴되면 함수 내에서 사용되던 지역변수들은 스택에서 사라지며 컴파일 타임에 스택의 크기가 정해진다. 정확히는 스택에 쌓인 데이터들이 사라지는 것이 아니라 현재 스택의 최상위 위치를 가리키는 ESP레지스터가 다른 값을 가리키게 된다. (LEAVE명령어 등) 높은주소에서 낮은주소로 데이터가 쌓이는 구조이다.힙(Heap) 필요에 의해 동적으로 생성되는 메모리 영역으로, 대표적으로는 C언어에서의 malloc함수가 있다. 낮은주소에서 높은주소로 데이터가 쌓이는 구조이다.BSS 초기화 되지 않은 데이터들이 존재하는 영역Data 초기화 된 데이터들의 영역Text(Code) 실행 명령어들이 존재하는 영역으로, 읽기전용으로 되어있어 런타임시 수정될 경우 에러가 발생한다.참고 스택과 힙은 동일한 영역을 사용하고 있으며 스택과 힙 중 어느 한쪽이라도 영역을 침범하게 되면 overflow가 발생해 프로그램이 종료된다. " }, { "title": "[BOJ 10807] 개수 세기", "url": "/posts/10807-%EA%B0%9C%EC%88%98-%EC%84%B8%EA%B8%B0/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 10807", "date": "2022-01-23 14:52:18 +0900", "snippet": "개수 세기 (10807번)https://www.acmicpc.net/problem/10807풀이방법 입력값을 모두 받고 v와 동일한 값을 체크함import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); int[] numbers = new int[N]; StringTokenizer st = new StringTokenizer(br.readLine()); for(int i=0; i&amp;lt;N; i++) { numbers[i] = Integer.parseInt(st.nextToken()); } int v = Integer.parseInt(br.readLine()); int sameCount = 0; for(int i=0; i&amp;lt;N; i++) { if (numbers[i] == v) sameCount++; } System.out.println(sameCount); }}" }, { "title": "[BOJ 3273] 두 수의 합", "url": "/posts/3273-%EB%91%90-%EC%88%98%EC%9D%98-%ED%95%A9/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 3273", "date": "2022-01-23 14:19:08 +0900", "snippet": "두 수의 합 (3273번)https://www.acmicpc.net/problem/3273풀이방법 a[i]와 a[j]를 더한 값이 최대 2백만이므로, 배열의 크기를 2백만으로 주었음 배열 인덱스에 입력받은 값을 주어 해당 인덱스에 1을 설정 x-i를 하면 i일때 x가 되기 위한 값이 나오므로 arr[x-i]를 이용 arr[i] == 0인 경우 해당 값을 입력받지 않았다는 것이므로 패스 x-i &amp;gt; i는 문제 설명의 a[i] + a[j] = x (1 ≤ i &amp;lt; j ≤ n)을 만족하기 위한 조건import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = null; int[] arr = new int[2_000_001]; int n = Integer.parseInt(br.readLine()); st = new StringTokenizer(br.readLine()); int max = 0; int index = 0; for (int i=0; i&amp;lt;n; i++) { index = Integer.parseInt(st.nextToken()); arr[index] = 1; max = Math.max(max, index); } int x = Integer.parseInt(br.readLine()); int pairCount = 0; for(int i=1; i&amp;lt;=max; i++) { if (x-i &amp;gt; i &amp;amp;&amp;amp; arr[i] != 0 &amp;amp;&amp;amp; arr[x-i] == 1) { pairCount++; } } System.out.println(pairCount); }}" }, { "title": "[BOJ 1475] 방 번호", "url": "/posts/1475-%EB%B0%A9-%EB%B2%88%ED%98%B8/", "categories": "BOJ, Problems", "tags": "BOJ, 1475, 백준", "date": "2022-01-23 12:35:30 +0900", "snippet": "방 번호 (1475번)https://www.acmicpc.net/problem/1475풀이방법 0~9 배열을 1로 초기화 입력값을 하나씩 가져와 숫자로 변환 후 숫자에 해당하는 배열에 1뺌 6, 9인 경우 6 또는 9의 개수를 1뺌 배열의 숫자가 0인 경우 한세트가 더 필요하므로 0~9까지 각각 1씩 더한 후 해당 숫자를 1뺌 import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); String roomNumber = st.nextToken(); int setCount = 1; int[] numberCount = new int[10]; for(int i=0; i&amp;lt;=9; i++) { numberCount[i] = 1; } int number = 0; for(int i=0; i&amp;lt;roomNumber.length(); i++) { number = roomNumber.charAt(i) - &#39;0&#39;; if (numberCount[number] == 0) { if (number == 6 &amp;amp;&amp;amp; numberCount[9] != 0) number = 9; else if (number == 9 &amp;amp;&amp;amp; numberCount[6] != 0) number = 6; else { for (int j = 0; j &amp;lt;= 9; j++) numberCount[j] += 1; setCount++; } } numberCount[number] -= 1; } System.out.println(setCount); }}" }, { "title": "반가산기와 전가산기", "url": "/posts/%EB%B0%98%EA%B0%80%EC%82%B0%EA%B8%B0%EC%99%80-%EC%A0%84%EA%B0%80%EC%82%B0%EA%B8%B0/", "categories": "CS", "tags": "CS, 반가산기, 전가산기", "date": "2022-01-10 22:18:48 +0900", "snippet": "디지털논리회로1) 논리게이트 - AND: 두 개의 입력이 모두 참(true)일 때만 참(true)이 된다. - OR: 두 개의 입력 중 하나라도 참(true)일 경우에만 참(true)이 된다. - INVERTER (NOT): 입력값이 반전된 값이 출력된다. - NAND (NOT AND): AND의 반대로, 입력값이 모두 거짓(false)일 때만 참(true)이 된다. - NOR (NOT OR): OR의 반대로, 입력값이 하나라도 거짓(false)인 경우 참(true)이 된다. - XOR: 입력값이 서로 반대일 경우에만 참(true)이 된다.2) 비트의 순서 - 1byte (8bit) | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | |-----------|---|---|---|---|---|---|---| |MSB(부호비트)|2^6|2^5|2^4|2^3|2^2|2^1|2^0|3) 반가산기 (half-adder) - 1비트 2진수 1과 0을 더했을 때의 결과는 01이 된다. 따라서 결괏값01에서 두번째 비트인 0은 자리올림(carry)이 되고 첫번째 비트인 1은 합(sum)이 된다.4) 전가산기 (full-adder) - 2비트 2진수 01과 01을 더했을 때의 결과는 10이 된다. 두 2진수의 첫번째 비트인 1과 1을 더하게 되면 10이 되고 결괏값의 첫번째 비트 1은 자리올림(carry)이 되며 두번째 비트 0은 합(sum)이 된다. 자리올림(carry)이 1이기 때문에 입력값의 두번째 비트인 0과 0을 더할 때 자리올림(carry)값을 더해주면 최종 결과는 10이 된다. - 따라서 전가산기는 반가산기 2개와 OR연산 1개가 필요하다.반가산기 구현하기 반가산기를 구현하기 위해서는 논리게이트를 이용해야 한다. 두 비트를 더했을 때의 합(sum)과 자리올림(carry)을 구해야 한다. 합(sum)은 두 비트 중 하나만 1인 경우에만 1이 되므로 XOR 연산을 이용한다. 자리올림(carry)는 두 비트 모두 1인 경우에만 1이 되므로 AND 연산을 이용한다. 합(sum)구현 두 개의 입력값이 다를 경우에만 true가 되어야 한다. 두 개의 입력값이 다르다는 것은 1, 0, 0, 1인 경우인데 서로 더했을 때 결과값은 1이 되기 때문에 자리올림 수는 0이 되고 합은 1이 된다. 두 개의 입력값이 같다면 자리올림 수가 1이 되거나 합이 0이 되는 경우만 존재하므로 이 경우에는 false가 되어야 한다. fun sum(bitA: Boolean, bitB: Boolean): Boolean { return bitA xor bitB } 합(sum)구현 테스트 fun sumTest() { // SUM 함수 테스트 println(&quot;SUM 함수 테스트&quot;) println(sum(true, true)) println(sum(true, false)) println(sum(false, true)) println(sum(false, false)) } 결과 false true true false 자리올림(carry)구현 자리올림(carry)는 두 개의 입력값을 더했을 때 자리올림이 되는 경우 true를 반환해야 한다. 즉, 1, 1인 경우에만 결괏값이 10이 되므로 자리올림비트를 설정해주어야 한다. fun carry(bitA: Boolean, bitB: Boolean): Boolean { return bitA and bitB } 테스트 fun carryTest() { // CARRY 함수 테스트 println(&quot;CARRY 함수 테스트&quot;) println(carry(true, true)) println(carry(true, false)) println(carry(false, true)) println(carry(false, false)) } 결과 true false false false halfAdder 함수 구현 및 테스트 두 개의 비트를 입력받아 합(sum)과 자리올림(carry)을 배열로 리턴하도록 구현하였다. fun halfadder(bitA: Boolean, bitB: Boolean): BooleanArray { val answer = BooleanArray(2) answer[0] = carry(bitA, bitB) answer[1] = sum(bitA, bitB) return answer } 테스트 fun halfadderTest(bitA: Boolean, bitB: Boolean) { println(&quot;halfadder 함수 테스트&quot;) println(&quot;bitA = $bitA&quot;) println(&quot;bitB = $bitB&quot;) var result = halfadder(bitA, bitB) println(&quot;결과 = [${result[0]}, ${result[1]}]&quot;) } 결과 bitA = true bitB = true 결과 = [true, false] bitA = true bitB = false 결과 = [false, true] bitA = false bitB = true 결과 = [false, true] bitA = false bitB = false 결과 = [false, false] 전가산기 구현하기 두 개의 비트와 한 개의 자리올림 비트를 입력받아 합(sum)과 자리올림(carry)을 배열로 리턴하도록 구현하였다. 전가산기는 2진수 한 자리를 계산하고, 자리올림 수를 포함해 출력한다. 다음 자리를 계산할 때 이전에 출력한 자리올림 수를 이용해 다시 계산한다. 예를들어, 11과 01을 더한다고 가정했을 때 아래와 같이 계산된다. 1 1 1 1 1 1 + 0 1 =&amp;gt; + 0 1 =&amp;gt; 0 1 =&amp;gt; ... ------- ------- + 1 (자리올림 수) 0 (자리올림 수 1) --------- 0 fun fulladder(bitA: Boolean, bitB: Boolean, carry: Boolean): BooleanArray { val curHalfAdder = halfadder(bitA, bitB) val curCarry = curHalfAdder[0] val curSum = curHalfAdder[1] val nextHalfAdder = halfadder(carry, curSum) val nextCarry = nextHalfAdder[0] val nextSum = nextHalfAdder[1] val answer = BooleanArray(2) answer[0] = curCarry or nextCarry answer[1] = nextSum return answer } 테스트 fun fulladderTest(bitA: Boolean, bitB: Boolean, carry: Boolean) { println(&quot;fulladder 함수 테스트&quot;) println(&quot;bitA = $bitA&quot;) println(&quot;bitB = $bitB&quot;) println(&quot;carry = $carry&quot;) var result = fulladder(bitA, bitB, carry) println(&quot;결과 = [${result[0]}, ${result[1]}]&quot;) } 결과 bitA = true bitB = true carry = true 결과 = [true, true] bitA = true bitB = false carry = true 결과 = [true, false] " }, { "title": "시간복잡도와 공간복잡도", "url": "/posts/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84%EC%99%80-%EA%B3%B5%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/", "categories": "자료구조", "tags": "시간복잡도, Time Complexity, 공간복잡도, Space Complexity", "date": "2022-01-10 21:40:59 +0900", "snippet": "시간복잡도 (Time Complexity) 입력 데이터가 특정 알고리즘을 거쳐 결과가 나오는데 걸리는 시간을 의미한다. 시간은 정확히 몇 초가 걸린다는 의미가 아닌 데이터의 증가에 따른 시간(연산속도)의 증가 정도를 말한다. 시간복잡도는 대입연산, 사칙연산, 비교구문, 함수호출등의 연산을 기준으로 계산한다. 시간복잡도는 최선의 경우, 평균의 경우, 최악의 경우로 나뉘어진다. 시간복잡도 내용 최선의 경우(빅-오메가) 최선의 상황을 기준으로 시간복잡도 측정대부분의 알고리즘은 빅-오메가로 시간복잡도를 측정했을 때 만족할만한 결과가 나오기 때문에 실제로 잘 쓰이지 않음특정 배열을 탐색하는 알고리즘에서 찾고자하는 값이 첫번째로 있을 경우 평균의 경우(빅-세타) 평균적인 상황을 기준으로 시간복잡도를 측정평균적인 상황이 무엇인지에 대한 문제가 발생알고리즘이 복잡할 경우 평균적인 상황을 구하기가 쉽지 않음 최악의 경우(빅-오) 최악의 상황을 기준으로 시간복잡도를 측정최악의 상황을 기준으로 측정하면 입력 데이터의 개수가 많더라도 이정도의 성능은 보장한다는 뜻이 됨대부분 알고리즘의 시간복잡도를 표현할 때 빅-오로 표현함특정 배열에서 찾고자하는 값이 없을 경우 빅-오(Big-O) 표기법 시간복잡도를 표현한 다항식에서 최고차항의 차수가 빅-오가 된다. 100n^3 + 999999n^2 + 10에서 빅-오 표기법을 이용하면 O(n^3)이 된다. n의 값이 크면 클수록 100n^3과 999999n^2의 차이가 발생하게 된다. 999999n^2도 충분히 큰 수이지만 제외한 이유는 데이터의 증가에 따른 시간의 증가 정도를 표현하기 때문이다.출처 및 참고사이트 참고사이트 윤성우의 열혈 자료구조공간복잡도 (Space Complexity) 알고리즘을 수행할 때 필요한 메모리의 총량을 의미한다. Space Complexity = Auxiliary Space + Input Size Space Auxiliary Space는 알고리즘을 실행하면서 필요한 임시변수 등을 의미한다. Input Size는 알고리즘에 전달되는 파라미터 값이나 문제해결을 하는데 사용되는 변수를 의미한다.프로그램의 메모리 사용 프로그램이 메모리를 사용할 때는 아래와 같다. 프로그램의 명령어들 컴파일러에 의해 컴파일된 명령어 mov, sub, … 환경적인 부분 A함수에서 B함수를 호출하면 A함수의 다음 위치 및 A함수에서 사용된 변수값들을 스택에 PUSH하고 B함수가 종료되면 A함수의 변수값들을 다시 POP해서 원래 내용대로 돌아오는 행위들 데이터 공간 변수 또는 상수의 메모리 양 알고리즘에서 공간복잡도를 구할때는 보통 데이터 공간을 이용해 계산한다.출처 및 참고사이트 참고사이트1 참고사이트2" }, { "title": "자료구조와 알고리즘", "url": "/posts/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/", "categories": "자료구조", "tags": "자료구조, Data Structure, 알고리즘, algorithm", "date": "2022-01-10 21:27:54 +0900", "snippet": "자료구조와 알고리즘 자료구조가 무엇인지 위키를 확인해보면 자료구조는 효율적인 접근 및 수정을 가능하게 하는 자료의 조직, 관리, 저장을 의미한다고 나와있다. 위의 말 그대로 자료를 어떻게 구성(조직)할 것이고 어떤 방식으로 관리하고 저장할 것인지를 말한다. 자료구조는 알고리즘과 밀접한 관계를 맺고 있는데, 한가지 간단한 예를 들어보면 다음과 같다. [예시] A가 일하는 편의점에 홈런볼 5박스가 들어왔는데 박스마다 유통기한이 다르게 들어왔으며 쌓여있는 순서도 유통기한 순서에 맞게 쌓여있는 것이 아니라 뒤죽박죽 섞인채로 쌓여있었다. A는 홈런볼 재고관리를 쉽게하기 위해 유통기한이 가장 길게 남아있는 박스를 아래에 쌓고 위로 쌓을수록 유통기한이 짧게 남은 박스를 올려두었고, 맨 위에 유통기한이 가장 짧게 남은 박스의 홈런볼부터 차례대로 매대에 진열해 놓았다. 진열된 홈런볼들이 다 팔릴때마다 한박스씩 맨 위에 쌓여있는 박스를 바닥으로 내려 홈런볼들을 꺼낸 후 진열하였다. 위 예시에서 홈런볼은 자료를 의미한다. 그리고 이 홈런볼들을 모아놓은 박스를 조직이라고 할 수 있다. 즉, 관련있는 것들(홈런볼)을 어떤 방식으로 구성(박스)할 것인지를 말한다. 그리고 유통기한 순서대로 홈런볼을 판매하는데 이것을 관리라고 한다. 이 박스들을 유통기한 순서대로 가장 길게 남은 박스는 아래에 두고 위로는 유통기한이 짧은 박스를 쌓아두는데 이 쌓아두는 것을 저장이라고 한다. 마지막으로 맨 위에 쌓여있는 박스를 바닥으로 내려 홈런볼을 꺼내 진열하는 행위를 알고리즘이라고 한다. 위 저장방식은 LIFO(Last-In First-Out)로 나중에 들어간 데이터가 먼저 나오는 자료구조인 스택을 이용하였으며, 알고리즘은 이 자료구조를 이용하여 어떻게 문제를 해결하는지를 말한다. 즉, 자료구조가 결정되어야 그에 맞는 알고리즘을 결정할 수 있기 때문에 자료구조와 알고리즘은 밀접한 관계를 맺고 있다고 볼 수 있다. 물론 자료구조가 달라지면 알고리즘도 바뀌어야 한다. 위 예시에서 스택 자료구조가 아닌 큐(Queue) 자료구조가 쓰인다면 그에 맞는 알고리즘(맨 위의 상자를 아래로 내린 후 홈런볼을 꺼내는 행위)도 바뀌어야 한다는 뜻이다.자료구조와 알고리즘을 배우는 이유? 어떤 문제를 해결할 때 어떤 자료구조(배열, 스택, 큐 등)를 사용해서 어떤 알고리즘을 사용할지에 따라 성능에 영향을 미치게 된다. 메모리를 적게 사용할 것인지, CPU를 적게 사용할 것인지에 따라서도 달라지게 된다. 예를 들어서, 1~100까지의 합을 구한다고 할 때 배열에 1부터 100까지 넣은 후 반복해서 더해주는 방법이 있다. 하지만 데이터의 양을 20억까지 늘린다면 계산하는 시간도 오래걸릴 뿐더러 배열을 이용하기 때문에 메모리 또한 많이 이용할 것이다. 이럴경우 등차수열의 합을 이용하면 메모리와 계산시간을 많이 줄여줄 수 있다." }, { "title": "[BOJ 17427] 약수의 합 2", "url": "/posts/17427-%EC%95%BD%EC%88%98%EC%9D%98-%ED%95%A9-2/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 17427", "date": "2022-01-05 22:21:52 +0900", "snippet": "약수의 합 2 (17427번)https://www.acmicpc.net/problem/17427시행착오 첫번째 시도 : 처음 문제를 봤을 때 시간 제한이 0.5초인걸 보고 하나씩 약수를 구한 후 더하면 시간초과가 발생할 것 같았다. 대략 1억번 반복할 때 1초라고 얘기를 들은적이 있는데 1,000,000 * 1,000,000이면 1조라는 큰 값이 나온다. 시간복잡도 : O(N^2) 두번째 시도 : 소인수분해를 통해서도 약수의 합을 구할 수 있어서 구현했지만 10,000을 넣어도 시간이 오래걸렸다. 아마 소인수분해를 할 때 계속해서 나누기 때문에 오래걸린 것으로 판단했다. 시간복잡도 : O(N^2) 마지막 시도 : 우선 1~10까지의 약수를 모두 구해보고 어떤 규칙이 있지 않을까 생각했다. 왜냐하면 분명 시간내에 풀기 위해서는 O(N)의 시간복잡도는 가져야한다고 판단했기 때문이다. 그래서 규칙을 찾아본 결과 N을 1~N까지 나눈 값이 1~N 까지의 약수들을 모두 포함하고 있었다. 1~10까지의 약수들 중1의 개수 : 10개2의 개수 : 5개3의 개수 : 3개4의 개수 : 2개5의 개수 : 2개6의 개수 : 1개7의 개수 : 1개8의 개수 : 1개9의 개수 : 1개10의 개수 : 1개를 가지게 됨을 알 수 있었다. import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); long answer = 0; for(int i=1; i&amp;lt;=N; i++) { answer += i * (N/i); } System.out.println(answer); }}" }, { "title": "[BOJ 2092] KMP는 왜 KMP일까?", "url": "/posts/2902-KMP%EB%8A%94-%EC%99%9C-KMP%EC%9D%BC%EA%B9%8C/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 2092", "date": "2022-01-03 21:30:24 +0900", "snippet": "KMP는 왜 KMP일까? (2902번)https://www.acmicpc.net/problem/2902풀이방법import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str = br.readLine(); StringBuilder sb = new StringBuilder(); sb.append(str.charAt(0)); for(int i=1; i&amp;lt;str.length(); i++) { if (str.charAt(i) == &#39;-&#39;) { sb.append(str.charAt(i+1)); } } System.out.println(sb); }}" }, { "title": "[BOJ 4375] 1", "url": "/posts/4375-1/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 4375", "date": "2022-01-02 16:02:00 +0900", "snippet": "1 (4375번)https://www.acmicpc.net/problem/4375이전풀이 BigInteger를 이용해 풀었으나 성능이 좋지 않았다. 이전풀이문제설명 1로만 이루어진 n의 배수를 찾는다는 것은 1로만 이루어진 숫자 예)111를 n으로 나눴을 때 나누어 떨어지는가? 를 묻는 것이다. 예제 출력의 3은 111이 되고 6은 111111, … 이 된다는 뜻이 된다.풀이방법 Modular 연산을 이용해 풀 수 있는 문제이다.1) (A+B)%C는 ((A%C) + (B%C))%C와 같다2) (A×B)%C는 ((A%C) × (B%C))%C와 같다 위 두가지 조건을 이용해 문제를 풀 수 있다. 첫 번째 조건을 보면 (A+B)%C는 ((A%C) + (B%C))%C와 같다고 하였으므로 결과는 아래와 같다. 1) A = 1%X2) B = 11%X3) C = 111%X4) D = 1111%X에서 A는 (0+1)%X = 1B는 (10+1)%X = (((A*10)%X) + (1%X))%XC는 (110+1)%X = (((B*10)%X) + (1%X))%XD는 (1110+1)%X = (((C*10)%X) + (1%X))%X...이 된다. 위의 설명에 따라 1, 11, 111, 1111, …을 순차적으로 구해주면 답이 나오게 된다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str = &quot;&quot;; StringBuilder sb = new StringBuilder(); int n = 0; int remainder = 1; int count = 1; while ((str = br.readLine()) != null) { n = Integer.parseInt(str); if (n == 1) { System.out.println(1); continue; } count = 1; remainder = 1; while (remainder != 0) { remainder = (10 * remainder + 1) % n; count++; } sb.append(count).append(&#39;\\n&#39;); } System.out.println(sb); }}" }, { "title": "[BOJ 1759] 암호 만들기", "url": "/posts/1759-%EC%95%94%ED%98%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 1759", "date": "2022-01-02 14:53:43 +0900", "snippet": "암호 만들기 (1759번)https://www.acmicpc.net/problem/1759풀이방법 재귀를 이용해 문제를 해결할 수 있다. 문제 내용 중 암호를 이루는 알파벳이 증가하는 순서로 배열되었을 것이라고 하였으므로 입력받은 C개의 문자들을 정렬해주었다. 최소 한 개의 모음과 최소 두 개의 자음으로 구성되어 있다고 하였으므로 자음과 모음의 개수를 세고 조건에 맞을 경우 출력해주어야 한다. 자음과 모음을 판단하는 checkVowel함수를 만들고 모음일 경우 true, 자음일 경우 false를 반환하도록 하였다. 중복되지 않는 순열을 구하는 방법으로 정답을 구할 수 있다. solve함수의 매개변수는 아래와 같다. arr : 입력받은 문자 C개를 정렬한 배열 vowelCount : 모음의 개수 consonantCount : 자음의 개수 curIndex : 중복을 뽑지 않으며 증가하는 순서대로 뽑기 위한 변수 r : 뽑을 개수 c : 현재 뽑은 개수 및 result 배열에 들어갈 위치 지정 import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.Arrays;import java.util.StringTokenizer;public class Main { private static StringBuilder sb = new StringBuilder(); private static char[] result = null; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int L = Integer.parseInt(st.nextToken()); result = new char[L]; int C = Integer.parseInt(st.nextToken()); char[] arr = new char[C]; st = new StringTokenizer(br.readLine()); int index = 0; while (st.hasMoreTokens()) { arr[index++] = st.nextToken().charAt(0); } Arrays.sort(arr); solve(arr, 0, 0, 0, L, 0); System.out.println(sb); } private static void solve(char[] arr, int vowelCount, int consonantCount, int curIndex, int r, int c) { if (c == r) { if (vowelCount &amp;gt;= 1 &amp;amp;&amp;amp; consonantCount &amp;gt;= 2) { sb.append(result).append(&#39;\\n&#39;); } return; } else { for(int i=curIndex; i&amp;lt;arr.length; i++){ result[c] = arr[i]; if (checkVowel(arr[i])) { solve(arr, vowelCount+1, consonantCount, i+1, r, c+1); } else { solve(arr, vowelCount, consonantCount+1, i+1, r, c+1); } } } } private static boolean checkVowel(char c) { if (c == &#39;a&#39; || c == &#39;e&#39; || c == &#39;i&#39; || c == &#39;o&#39; || c == &#39;u&#39;) { return true; } return false; }}" }, { "title": "[BOJ 5565] 영수증", "url": "/posts/5565-%EC%98%81%EC%88%98%EC%A6%9D/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 5565", "date": "2021-12-30 23:01:12 +0900", "snippet": "영수증 (5565번)https://www.acmicpc.net/problem/5565풀이방법 첫번째 줄에는 10권의 총 가격이 주어진다고 하였으므로 두번째 줄부터 마지막 줄 까지의 합을 첫번째 값에서 빼주면 정답을 유추할 수 있다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int totalSum = Integer.parseInt(br.readLine()); int sum = 0; for(int i=0; i&amp;lt;9; i++) { sum += Integer.parseInt(br.readLine()); } System.out.println(totalSum - sum); }}" }, { "title": "[BOJ 1037] 약수", "url": "/posts/1037-%EC%95%BD%EC%88%98/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 1037", "date": "2021-12-29 23:00:54 +0900", "snippet": "약수 (1037번)https://www.acmicpc.net/problem/1037풀이방법 문제 내용에서 어떤 수 N의 진짜 약수가 모두 주어진다 하였으므로 정렬 후 맨 처음과 마지막을 곱하면 N을 구할 수 있다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.StringTokenizer;import java.util.Arrays;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); StringTokenizer st = new StringTokenizer(br.readLine()); int[] arr = new int[N]; for(int i=0; i&amp;lt;N; i++) { arr[i] = Integer.parseInt(st.nextToken()); } Arrays.sort(arr); System.out.println(arr[0] * arr[N-1]); }}" }, { "title": "[BOJ 6603] 로또", "url": "/posts/6603-%EB%A1%9C%EB%98%90/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 6603", "date": "2021-12-28 17:41:29 +0900", "snippet": "로또 (6603번)https://www.acmicpc.net/problem/6603풀이방법 주어지는 로또 번호들은 오름차순으로 주어지며 사전 순으로 출력해야 하므로 주어진 번호 중 6개를 이용해 조합하면 된다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { private static int[] result = new int[6]; private static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = null; int N = 0; while(true) { st = new StringTokenizer(br.readLine()); N = Integer.parseInt(st.nextToken()); if (N == 0) { break; } int[] arr = new int[N]; for(int i=0; i&amp;lt;arr.length; i++) { arr[i] = Integer.parseInt(st.nextToken()); } solve(arr, 0, 0); sb.append(&#39;\\n&#39;); } System.out.println(sb); } private static void solve(int[] arr, int curIndex, int c) { if (c == 6) { for(int i : result) { sb.append(i).append(&#39; &#39;); } sb.append(&#39;\\n&#39;); return; } else { for(int i=curIndex; i&amp;lt;arr.length; i++) { result[c] = arr[i]; solve(arr, i+1, c+1); } } }}" }, { "title": "[BOJ 10971] 외판원 순회 2", "url": "/posts/10971-%EC%99%B8%ED%8C%90%EC%9B%90-%EC%88%9C%ED%9A%8C-2/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 10971, 재풀이 필요", "date": "2021-12-28 16:28:19 +0900", "snippet": "외판원 순회 2 (10971번)https://www.acmicpc.net/problem/6603이전풀이 처음에는 모든 순열을 구해서 ArrayList에 저장하고 그 순열을 이용해 최소값을 구하도록 구혔했었다. 그러다보니 속도에서 700ms 이상의 퍼포먼스가 나왔고 아래와 같은 방법으로 수정한 결과 300ms대 퍼포먼스가 나왔다. 그러나 다른 사람들의 풀이를 보면 DP를 이용한 풀이가 속도면에서 우월했다. DP 또는 코드를 개선해 개선할 필요가 있다.풀이방법 순열을 구할 때마다 최소값을 계산하는 방식으로 구현하였다. 원래의 도시로 다시 돌아와야 하므로 1, 2, 3, 4로 순회할 경우 1, 2, 3, 4, 1로 수정한 후 계산했다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { private static int[] result = null; private static int min = Integer.MAX_VALUE; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); result = new int[N+1]; StringTokenizer st = null; int[] arr = new int[N]; boolean[] visited = new boolean[N]; for(int i=0; i&amp;lt;N; i++) { arr[i] = i+1; } int[][] W = new int[N+1][N+1]; for(int i=1; i&amp;lt;=N; i++) { st = new StringTokenizer(br.readLine()); for(int j=1; j&amp;lt;=N; j++) { W[i][j] = Integer.parseInt(st.nextToken()); } } solve(arr, W, visited, N, 0); System.out.println(min); } private static void calculate(int[][] W, int[] tmp) { boolean canMove = true; int sum = 0; for(int j=0; j&amp;lt;tmp.length-1; j++) { if (W[tmp[j]][tmp[j+1]] == 0) { canMove = false; } sum += W[tmp[j]][tmp[j+1]]; } if (canMove) { min = Math.min(min, sum); } } private static void solve(int[] arr, int[][] W, boolean[] visited, int r, int c) { if (c == r) { result[arr.length] = result[0]; calculate(W, result); } else { for(int i=0; i&amp;lt;arr.length; i++) { if (!visited[i]) { visited[i] = true; result[c] = arr[i]; solve(arr, W, visited, r, c+1); visited[i] = false; } } } }}" }, { "title": "[BOJ 10819] 차이를 최대로", "url": "/posts/10819-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%B5%9C%EB%8C%80%EB%A1%9C/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 10819", "date": "2021-12-28 14:22:42 +0900", "snippet": "차이를 최대로 (10819번)https://www.acmicpc.net/problem/10819풀이방법 입력받은 배열을 이용해 모든 순열을 구함과 동시에 최대값을 구해주면 된다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { private static int max = 0; private static int[] result = null; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); StringTokenizer st = new StringTokenizer(br.readLine()); int[] arr = new int[N]; boolean[] visited = new boolean[N]; result = new int[N]; for(int i=0; i&amp;lt;N; i++) { arr[i] = Integer.parseInt(st.nextToken()); } solve(arr, visited, N, 0); System.out.println(max); } private static void solve(int[] arr, boolean[] visited, int r, int c) { if (c == r) { int sum = 0; for(int i=0; i&amp;lt;arr.length-1; i++) { sum += Math.abs(result[i] - result[i+1]); } max = Math.max(max, sum); return; } else { for (int i=0; i&amp;lt;arr.length; i++) { if (!visited[i]) { visited[i] = true; result[c] = arr[i]; solve(arr, visited, r, c+1); visited[i] = false; } } } }}" }, { "title": "[BOJ 10974] 모든 순열", "url": "/posts/10974-%EB%AA%A8%EB%93%A0-%EC%88%9C%EC%97%B4/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 10974", "date": "2021-12-28 10:41:17 +0900", "snippet": "모든 순열 (10974번)https://www.acmicpc.net/source/36738364풀이방법 1부터 N까지의 수로 이루어진 모든 순열을 사전순으로 출력하는 문제이다. 방문하지 않은 데이터를 이용해 순열을 만들어야 하므로 visited 배열을 추가해 구현하였다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;public class Main { private static StringBuilder sb = new StringBuilder(); private static int[] result = null; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); int[] arr = new int[N]; result = new int[N]; boolean[] visited = new boolean[N]; for(int i=0; i&amp;lt;N; i++) { arr[i] = i+1; } solve(arr, visited, N, 0); System.out.println(sb); } private static void solve(int[] arr, boolean[] visited, int r, int c) { if (c == r) { for(int i : result) { sb.append(i).append(&#39; &#39;); } sb.append(&#39;\\n&#39;); return; } else { for(int i=0; i&amp;lt;arr.length; i++) { if (!visited[i]) { visited[i] = true; result[c] = arr[i]; solve(arr, visited, r, c+1); visited[i] = false; } } } }}" }, { "title": "[BOJ 10973] 이전 순열", "url": "/posts/10973-%EC%9D%B4%EC%A0%84-%EC%88%9C%EC%97%B4/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 10973", "date": "2021-12-27 14:49:45 +0900", "snippet": "이전 순열 (10973번)https://www.acmicpc.net/problem/10973풀이방법다음 순열 (10973) 과 비슷한 문제로, 반복문의 부등호 방향만 바꿔주면 된다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); StringTokenizer st = new StringTokenizer(br.readLine()); int[] arr = new int[N]; int index = 0; while (st.hasMoreTokens()) { arr[index++] = Integer.parseInt(st.nextToken()); } StringBuilder sb = new StringBuilder(); if (nextPermutation(arr)) { for(int i : arr) { sb.append(i).append(&#39; &#39;); } System.out.println(sb); } else { System.out.println(-1); } } private static boolean nextPermutation(int[] arr) { int i = arr.length-1; while (i &amp;gt; 0 &amp;amp;&amp;amp; arr[i-1] &amp;lt; arr[i]) { i--; } if (i &amp;lt;= 0) { return false; } int j = arr.length-1; while (arr[i-1] &amp;lt; arr[j]) { j--; } swap(arr, i-1, j); reverse(arr, i); return true; } private static void swap(int[] arr, int idx1, int idx2) { int tmp = arr[idx1]; arr[idx1] = arr[idx2]; arr[idx2] = tmp; } private static void reverse(int[] arr, int startIndex) { int endIndex = arr.length-1; while (startIndex &amp;lt;= endIndex) { swap(arr, startIndex++, endIndex--); } }}" }, { "title": "[BOJ 10972] 다음 순열", "url": "/posts/10972-%EB%8B%A4%EC%9D%8C-%EC%88%9C%EC%97%B4/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 10972", "date": "2021-12-27 11:59:32 +0900", "snippet": "다음 순열 (10972번)https://www.acmicpc.net/problem/10972풀이방법 주어진 입력 순열의 다음 순열을 구하는 문제이다. 모든 순열을 구하면서 입력받은 순열의 다음 순열을 구하게 되면 시간이 오래 걸리게 된다. 최악의 경우: 역순으로 입력받은 경우 위와 같은 방법으로는 시간이 오래 걸리기 때문에 다른 방법을 찾아봐야 한다. [1, 2, 3, 4, 5]로 이루어진 순열을 생각해보면 1XXXX, 2XXXX, 3XXXX, 4XXXX, 5XXXX 순으로 순열이 이루어져야 한다. 1XXXX는 다시 12XXX, 13XXX, 14XXX, 15XXX 로 이루어지고 2XXXX는 다시 21XXX, 23XXX, 24XXX, 15XXX 로 이루어진다. 위 X들은 오름차순이 되어야 한다. 위의 내용을 토대로 [3, 2, 5, 4, 1]이 주어졌을 때 이 순열의 다음 순열은 [3, 4, 1, 2, 5]가 되어야 한다. 그 이유는 32XXX를 생각했을 때 XXX가 모두 내림차순이므로 위 [3, 2, 5, 4, 1]은 32XXX로 시작하는 모든 수열에서 마지막이기 때문이다. 32XXX의 다음 순열은 34XXX가 되어야 하고, 34XXX로 시작하는 순열 중 제일 첫번째인 [3, 2, 5, 4, 1]의 다음 순열은 [3, 4, 1, 2, 5]가 된다. 위 예시를 잘 보면 결국 [3, 2, 5, 4, 1]에서 처음으로 32XXX보다 큰 값이 나올 수 있는 값은 34XXX 이므로 2와 4를 서로 교환하면 [3, 4, 5, 2, 1]이 되고34XXX로 시작하면서 제일 작은 수는 [3, 4, 5, 2, 1]에서 5, 2, 1을 역순으로 한 것이므로 뒤집어주면 된다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); StringTokenizer st = new StringTokenizer(br.readLine()); int[] arr = new int[N]; int index = 0; while (st.hasMoreTokens()) { arr[index++] = Integer.parseInt(st.nextToken()); } StringBuilder sb = new StringBuilder(); if (next_permutation(arr)) { for(int i : arr) { sb.append(i).append(&#39; &#39;); } System.out.println(sb); } else { System.out.println(-1); return; } } private static boolean next_permutation(int[] arr) { int i = arr.length-1; // 뒤에서부터 탐색했을 때 처음으로 오름차순이 아닌 부분 검색 // [3, 2, 5, 4, 1]에서 32XXX 부분이 됨 while (i&amp;gt;0 &amp;amp;&amp;amp; arr[i-1] &amp;gt; arr[i]) { i--; } // 순열의 마지막부터 첫번째까지 갔을 경우 모두 오름차순이므로 false 반환 // 첫번째부터 순열의 마지막까지는 내림차순이 되므로 if (i &amp;lt;= 0) { return false; } // 처음으로 오름차순이 아닌 부분보다 큰 값이 있을 경우 서로 교환 // [3, 2, 5, 4, 1]에서 4가 2보다 크므로 int j = arr.length-1; while (arr[j] &amp;lt; arr[i-1]) { j--; } swap(arr, i-1, j); // 오름차순이 아닌 부분 이후의 값들을 모두 역으로 교환 reverse(arr, i); return true; } private static void swap(int[] arr, int idx1, int idx2) { int a1 = arr[idx1]; arr[idx1] = arr[idx2]; arr[idx2] = a1; } private static void reverse(int[] arr, int startIndex) { int endIndex = arr.length-1; while (startIndex &amp;lt;= endIndex) { swap(arr, startIndex++, endIndex--); } }}" }, { "title": "[BOJ 15666] N과 M (12)", "url": "/posts/15666-N%EA%B3%BC-M-(12)/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 15666", "date": "2021-12-26 16:19:10 +0900", "snippet": "N과 M (12) (15666번)https://www.acmicpc.net/problem/15666풀이방법 중복되는 숫자가 주어질 수 있지만 중복되는 수열은 한 번 출력되어야 한다. 주어진 수에서 중복된 수를 제거하고 테스트해보면 출력과 동일한 결과가 나오는 것을 확인할 수 있다. 예제 2번을 1 7 9 세 수를 이용해 출력해보면 알 수 있음 단, 비내림차순이어야 하므로 선택한 값보다 작은 값은 선택할 수 없음 (curIndex변수를 이용해 선택) TreeSet을 이용하여 입력된 수들의 중복을 제거하고 다시 배열에 넣어준다. 중복이 제거된 수를 이용해 문제를 해결한다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.StringTokenizer;import java.util.TreeSet;import java.util.Iterator;public class Main { private static StringBuilder sb = new StringBuilder(); private static int[] result = null; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); result = new int[M]; TreeSet&amp;lt;Integer&amp;gt; ts = new TreeSet&amp;lt;&amp;gt;(); st = new StringTokenizer(br.readLine()); while (st.hasMoreTokens()) { ts.add(Integer.parseInt(st.nextToken())); } int index = 0; int[] arr = new int[ts.size()]; Iterator&amp;lt;Integer&amp;gt; iter = ts.iterator(); while (iter.hasNext()) { arr[index++] = iter.next(); } solve(arr, 0, M, 0); System.out.println(sb); } private static void solve(int[] arr, int curIndex, int r, int c) { if (c == r) { for(int i : result) { sb.append(i).append(&#39; &#39;); } sb.append(&#39;\\n&#39;); return; } else { for(int i=curIndex; i&amp;lt;arr.length; i++) { result[c] = arr[i]; solve(arr, i, r, c+1); } } }}" }, { "title": "[BOJ 15665] - N과 M (11)", "url": "/posts/15665-N%EA%B3%BC-M-(11)/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 15665", "date": "2021-12-26 15:37:21 +0900", "snippet": "N과 M (11) (15665번)https://www.acmicpc.net/problem/15665풀이방법 중복되는 숫자가 주어질 수 있지만 중복되는 수열은 한 번 출력되어야 한다. 주어진 수에서 중복된 수를 제거하고 테스트해보면 출력과 동일한 결과가 나오는 것을 확인할 수 있다. 예제 2번을 1 7 9 세 수를 이용해 출력해보면 알 수 있음 TreeSet을 이용하여 입력된 수들의 중복을 제거하고 다시 배열에 넣어준다. 중복이 제거된 수를 이용해 문제를 해결한다.import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.Iterator;import java.util.StringTokenizer;import java.util.TreeSet;public class Main { private static StringBuilder sb = new StringBuilder(); private static int[] result = null; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); result = new int[M]; st = new StringTokenizer(br.readLine()); TreeSet&amp;lt;Integer&amp;gt; ts = new TreeSet&amp;lt;&amp;gt;(); while (st.hasMoreTokens()) { ts.add(Integer.parseInt(st.nextToken())); } int index = 0; int[] arr = new int[ts.size()]; Iterator&amp;lt;Integer&amp;gt; iter = ts.iterator(); while (iter.hasNext()) { arr[index++] = iter.next(); } solve(arr, M, 0); System.out.println(sb); } private static void solve(int[] arr, int r, int c) { if (c == r) { for(int i : result) { sb.append(i).append(&#39; &#39;); } sb.append(&#39;\\n&#39;); return; } else { for(int i=0; i&amp;lt;arr.length; i++) { result[c] = arr[i]; solve(arr, r, c+1); } } }}" }, { "title": "[BOJ 15664] - N과 M (10)", "url": "/posts/15664-N%EA%B3%BC-M-(10)/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 15664", "date": "2021-12-26 14:31:17 +0900", "snippet": "N과 M (10) (15664번)https://www.acmicpc.net/problem/15664풀이방법 중복된 숫자가 주어질 수 있지만 중복된 순열은 출력하면 안된다는 조건이 있으므로 LinkedHashSet을 이용하였다. 일반적인 HashSet은 순서가 보장되지 않으나 LinkedHashSet은 입력된 순서에 따라 순서가 보장된다. 먼저 입력받은 숫자들을 정렬한 후 solve 함수에 전달해주었다. solve 함수의 전달인자는 다음과 같다.1) 첫번째 : 데이터가 들어있는 배열2) 두번째 : 현재 데이터 배열에 접근한 인덱스가 몇인지 전달하여 그 이후의 데이터들로만 고르도록 하기 위한 변수3) 세번째 : 몇 개를 고를 것인지에 대한 변수4) 네번째 : 현재 뽑은 개수 및 데이터 저장 위치import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.StringTokenizer;import java.util.Arrays;import java.util.Iterator;import java.util.LinkedHashSet;public class Main { private static StringBuilder sb = new StringBuilder(); private static int[] result = null; private static LinkedHashSet&amp;lt;String&amp;gt; ls = new LinkedHashSet&amp;lt;&amp;gt;(); public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); int[] arr = new int[N]; result = new int[M]; st = new StringTokenizer(br.readLine()); int index = 0; while (st.hasMoreTokens()) { arr[index++] = Integer.parseInt(st.nextToken()); } Arrays.sort(arr); solve(arr, 0, M, 0); Iterator&amp;lt;String&amp;gt; iter = ls.iterator(); while (iter.hasNext()) { sb.append(iter.next()).append(&#39;\\n&#39;); } System.out.println(sb); } private static void solve(int[] arr, int curIndex, int r, int c) { if (r == c) { for(int i : result) { sb.append(i).append(&#39; &#39;); } ls.add(sb.toString()); sb.delete(0, sb.length()); } else { for (int i=curIndex; i&amp;lt;arr.length; i++) { result[c] = arr[i]; solve(arr, i+1, r, c+1); } } }}" }, { "title": "[BOJ 15663] - N과 M (9)", "url": "/posts/15663-N%EA%B3%BC-M-(9)/", "categories": "BOJ, Problems", "tags": "BOJ, 백준, 15663", "date": "2021-12-25 22:31:45 +0900", "snippet": "N과 M (9) (15663번)https://www.acmicpc.net/problem/15663풀이방법 중복된 숫자가 주어질 수 있지만 중복된 순열은 출력하면 안된다는 조건이 있으므로 LinkedHashSet을 이용하였다. 일반적인 HashSet은 순서가 보장되지 않으나 LinkedHashSet은 입력된 순서에 따라 순서가 보장된다. 먼저 입력받은 숫자들을 정렬한 후 solve 함수에 전달해주었다. solve 함수의 전달인자는 다음과 같다.1) 첫번째 : 데이터가 들어있는 배열2) 두번째 : 나 자신을 제외해야 하므로 방문했는지 확인하는 변수3) 세번째 : 몇 개를 고를 것인지에 대한 변수4) 네번째 : 현재 뽑은 개수 및 데이터 저장 위치import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.Iterator;import java.util.StringTokenizer;import java.util.LinkedHashSet;import java.util.Arrays;import java.util.Set;public class Main { private static Set&amp;lt;String&amp;gt; set = new LinkedHashSet&amp;lt;&amp;gt;(); private static StringBuilder sb = new StringBuilder(); private static int[] result = null; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); int[] arr = new int[N]; boolean[] visited = new boolean[N]; result = new int[M]; st = new StringTokenizer(br.readLine()); int index = 0; while (st.hasMoreTokens()) { arr[index++] = Integer.parseInt(st.nextToken()); } Arrays.sort(arr); solve(arr, visited, M, 0); sb.delete(0, sb.length()); Iterator&amp;lt;String&amp;gt; iter = set.iterator(); while (iter.hasNext()) { sb.append(iter.next()).append(&#39;\\n&#39;); } System.out.println(sb); } private static void solve(int[] arr, boolean[] visited, int r, int c) { if (c == r) { for(int i : result) { sb.append(i).append(&#39; &#39;); } set.add(sb.toString()); sb.delete(0, sb.length()); return; } else { for(int i=0; i&amp;lt;arr.length; i++) { if (!visited[i]) { visited[i] = true; result[c] = arr[i]; solve(arr, visited, r, c+1); visited[i] = false; } } } }}" }, { "title": "백준(BOJ) 문제풀이 목록", "url": "/posts/%EB%B0%B1%EC%A4%80-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-%EB%AA%A9%EB%A1%9D/", "categories": "BOJ, 문제풀이 리스트", "tags": "BOJ, 문제풀이", "date": "2021-12-24 11:41:28 +0900", "snippet": "백준(BOJ) 문제풀이 목록 최종 업데이트 날짜 : 2022. 03. 17Bronze 1 명령 프롬프트 (1032) 단어 뒤집기 (9093) ROT13 (11655) 피보나치 수 2 (2748) 설탕 배달 (2839) BABBA (9625) 타일 장식물 (13301)Bronze 2 저항 (1076) 하얀 칸 (1100) 운동 (1173) 카드1 (2161) 알파벳 개수 (10808) 문자열 분석 (10820) 단어 길이 재기 (2743) 2진수 8진수 (1373) 이름 궁합 (15312) KMP는 왜 KMP일까? (2902) 일곱 난쟁이 (2309) 카드 역배치 (10804) 개수 세기 (10807)Bronze 3 플러그 (2010) 지수연산 (2052) 초콜릿 자르기 (2163) 시그마 (2355) 별 찍기 4 (2441) 별 찍기 5 (2442) 별 찍기 6 (2443) 별 찍기 7 (2444) Number Game (1975) 오각형, 오각형, 오각형… (1964) 문어 숫자 (1864) 생상점 (1703) 꼬리를 무는 숫자 나열 (1598) 공 (1547) 집 주소 (1284) 핸드폰 요금 (1267) 부호 (1247) 8진수 2진수 (1212) 직사각형에서 탈출 (1085) 분산처리 (1009) 점수계산 (2506) 네 수 (10824) 영수증 (5565) 지능형 기차 (2455) 상근이의 친구들 (5717)Bronze 4 TV 크기 (1297) A/B (1008) 손익분기점 (1712) 사파리월드 (2420) AFC 웜블던 (4299) 이칙연산 (15726) 오븐 시계 (2525) 인공지능 시계 (2530) 세수정렬 (2752) 주사위 세개 (2480) 체스판 조각 (3004) 상근날드 (5543) 타임 카드 (5575) 시험 점수 (5596) 17배 (5893) 평균 점수 (10039) 삼각형 외우기 (10101) 과자 (10156) 전자레인지 (10162) 쿠폰 (10179) 수도요금 (10707) 특별한 날 (10768) 10부제 (10797) 한글 (11282) 파일 옮기기 (11943) 과목선택 (11948) 팀 나누기 (13866) 정육각형과 삼각형 (14264) 전자레인지 (14470) 감정이입 (14623) 사분면 고르기 (14681) 폰 노이만과 파리 (14924) FA (14935) 연세대학교 (15680) 타일 채우기 4 (15700) 공백 없는 A+B (15873) 수찬은 마린보이야!! (15921) CASIO (15963) 나이 계산하기 (16199) 카드 뽑기 (16204) 베시와 데이지 (16321) 운동장 한 바퀴 (16486) 수학은 체육과목 입니다 2 (17362) 와글와글 숭고한 (17388) 헛간 청약 (19698) 뉴비의 기준은 뭘까? (19944) Darius님 한타 안 함? (20499) SASA 모형을 만들어보자 (23825)Bronze 5 16진수 (1550) 엄청난 부자2 (1271) 긴자리 계산 (2338) 검증수 (2475) A+B-2 (2558) 파티가 끝나고 난 뒤 (2845) 저작권 (2914) 킹,퀸,룩,비숍,나이트,폰 (3003) R2 (3046) 웰컴 (5337) 마이크로소프트 로고 (5338) 콜센터 (5339) 카드 게임 (5522) 심부름 가는 길 (5554) Next in line (6749) Plane (8370) 스타워즈 로고 (9653) 나부 함대 데이터 (9654) NFC West vs North (10170) 오늘 날짜 (10699) 큰 수 A+B (10757) ??! (10926) 한글 2 (11283) 꼬마 정민 (11382) 고려대학교 (11942) 큰 수 곱셈 (13277) 와이버스 부릉부릉 (14645) 나는 행복합니다 (14652) 조별과제를 하려는데 조장이 사라졌다 (16727) 나는 누구인가 (15733) A+B - 9 (15740) 수학은 체육과목 입니다 (15894) 새로운 시작 (15962) 이상한 기호 (15964) 오늘의 날짜는? (16170) 홍익대학교 (16394) 제리와 톰 (16430) 달달함이 넘쳐흘러 (17256) 엔드게임 스포일러 (17295) 스타후르츠 (17496) 1998년생인 내가 태국에서는 2541년생?! (18108) 세금 (20492) 큰 수 (BIG) (14928)Silver 1 물병 (1052) 골드바흐의 추측 (6588) 카드 구매하기 (11052) 카드 구매하기 2 (16194) 쉬운 계단 수 (10844) RGB거리 (1149) 동물원 (1309) 오르막 수 (11057) 스티커 (9465) 포도주 시식 (2156) 정수 삼각형 (1932) 타일 채우기 (2133) 카잉 달력 (6064) 그림 (1926) 미로 탐색 (2178) 숨바꼭질 (1697) 하노이 탑 이동 순서 (11729) Z (1074) 쿼드트리 (1992) 계란으로 계란치기 (16987)Silver 2 소수 구하기 (1929) 조합 0의 개수 (2004) 골드바흐 파티션 (17103) 1,2,3 더하기 5 (15990) 가장 긴 증가하는 부분 수열 (11053) 연속합 (1912) 1,2,3 더하기 3 (15988) 가장 큰 증가 부분 수열 (11055) 가장 긴 감소하는 부분 수 (11722) N과 M (9) (15663) N과 M (10) (15664) N과 M (11) (15665) N과 M (12) (15666) 차이를 최대로 (10819) 외판원 순회 2 (10971) 로또 (6603) 약수의 합 2 (17427) 부등호 (2529) 유기농 배추 (1012) 나이트의 이동 (7562) 종이의 개수 (1780) 부분수열의 합 (1182)Silver 3 숫자 정사각형 (1051) 스택 수열 (1874) 에디터 (1406) 쇠막대기 (10799) 후위 표기식2 (1935) GCD 합 (9613) 1로 만들기 (1463) 2xn 타일링 (11726) 2xn 타일링 2 (11727) 1,2,3 더하기 (9095) 이친수 (2193) 제곱수의 합 (1699) 사탕 게임 (3085) 수 이어쓰기 1 (1748) N과 M (1) (15649) N과 M (2) (15650) N과 M (3) (15651) N과 M (4) (15652) N과 M (5) (15654) N과 M (6) (15655) N과 M (7) (15656) N과 M (8) (15657) 다음 순열 (10972) 이전 순열 (10973) 모든 순열 (10974) 1 (4375) 스타트와 링크 (14889) 두 수의 합 (3273) 키로거 (5397) 색종이 만들기 (2630)Silver 4 킹 (1063) 문자열 (1120) 스택 (10828) 괄호 (9012) 큐 (10845) 덱 (10866) 접미사 배열 (11656) 소수 찾기 (1978) 팩토리얼 0의 개수 (1676) -2진수 (2089) 돌 게임 2 (9656) 회전하는 큐 (1021) 제로 (10773)Silver 5 요세푸스 (1158) 최대공약수와 최소공배수 (2609) 최소공배수 (1934) 다리 놓기 (1010) 거스름돈 (14916) 파스칼 삼각형 (15489) 날짜 계산 (1476) 약수 (1037) 방 번호 (1475) 재귀함수가 뭔가요? (17478)Gold 1 진법 변환 (1112)Gold 2Gold 3 오등큰수 (17299) 후위 표기식 (1918) 가장 긴 바이토닉 부분 수열 (11054)Gold 4 오큰수 (17298) 가장 긴 증가하는 부분 수열 4 (14002) 불! (4179)Gold 5 합분해 (2225) 연속합 2 (13398) 리모컨 (1107) 테트로미노 (14500) 암호 만들기 (1759) 약수의 합 (17425) 토마토 (7576) 적록색약 (10026) 토마토 (7569) N-Queen (9663)" }, { "title": "블로그 시작", "url": "/posts/%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%8B%9C%EC%9E%91/", "categories": "", "tags": "Start Blog", "date": "2021-12-23 16:18:01 +0900", "snippet": "테마 : Chirpy사용법 : Tutorial" } ]
